<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–åŠå‚³èªª ç´ æè¨ˆç®—æ©Ÿ</title>
    <!-- tailwindcss CDN only for local / testing use -->
    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
    body {
        font-family: 'Noto Sans TC', sans-serif;
        background: linear-gradient(180deg, #f5fafb 0%, #e6f3f4 100%);
        color: #1e293b; /* æ·±è—ç°æ–‡å­— */
    }

    .card {
        background: #ffffffd9; /* åŠé€æ˜ç™½å¡ç‰‡ */
        border: 1px solid #cde5e8;
        box-shadow: 0 2px 8px rgba(38,115,119,.15);
        border-radius: 10px;
        transition: all .25s ease;
    }

    .input-field {
        background-color: #f7fbfc;
        color: #1e293b;
        border: 1px solid #b6d7da;
        transition: border-color .25s, box-shadow .25s, background-color .25s;
    }

    .input-field:focus {
        border-color: #2cb5ab;
        box-shadow: 0 0 6px rgba(44,181,171,.4);
        outline: none;
        background-color: #f0fafa;
    }

    .input-field:disabled {
        background-color: #eef3f4;
        color: #94a3b8;
        border-color: #cbd5e1;
        cursor: not-allowed;
    }

    .btn-primary {
        background: linear-gradient(135deg, #31c9be 0%, #1a9e95 100%);
        color: #fffef8;
        border: 1px solid #21b8ac;
        box-shadow: 0 2px 6px rgba(34,180,168,.25);
        transition: background .3s, transform .15s;
    }

    .btn-primary:hover {
        background: linear-gradient(135deg, #45dfd3 0%, #23b7ac 100%);
        transform: translateY(-2px);
    }

    .result-item { background:#fffdf5; border-left:4px solid #f48b45; box-shadow: inset 0 0 8px rgba(244,139,69,.2); }
    .info-item   { background:#f0faf9; border-left:4px solid #2cb5ab; box-shadow: inset 0 0 8px rgba(44,181,171,.15); }
    .cost-item   { background:#fffbee; border-left:4px solid #facc15; box-shadow: inset 0 0 8px rgba(249,209,98,.2); }

    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button { opacity:.4; }

    /* æ²è»¸ */
    .custom-scrollbar::-webkit-scrollbar { width:8px; height:8px; }
    .custom-scrollbar::-webkit-scrollbar-track { background:#f2f8f9; }
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg,#b3dede 0%,#89cfcf 100%); border-radius:4px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg,#6dcacb 0%,#4fbebf 100%);
    }

    /* æ¨™é¡Œé¡è‰² */
    h1,h2,h3,h4 { color:#165f63; text-shadow:0 1px 2px rgba(22,95,99,.15); }
    .text-accent{ color:#1fb7ad; }
    .text-gold  { color:#d4a418; }
    .text-warning{ color:#d65a2d; }
  </style>
</head>

<body class="p-4 lg:p-6">
  <div class="w-full max-w-7xl mx-auto">
    <!-- ===== é é¦– ===== -->
    <header class="text-center mb-6">
      <h1 class="text-3xl md:text-4xl font-bold">æ–åŠå‚³èªª ç´ æè¨ˆç®—æ©Ÿ</h1>
    </header>

    <!-- ===== ç›®æ¨™æ™‚é–“ / ç¾åœ¨æ™‚é–“ ===== -->
    <div class="card rounded-lg p-4 shadow-lg mb-6 max-w-lg mx-auto">
      <div class="flex items-center justify-center gap-x-6">
        <div>
          <h3 class="text-lg font-semibold text-center mb-2">ç›®æ¨™æ™‚é–“</h3>
          <input type="datetime-local" id="target-time" class="input-field rounded w-full py-2 px-3">
        </div>
        <div>
          <h3 class="text-lg font-semibold text-center mb-2">ç¾åœ¨æ™‚é–“</h3>
          <!-- ä½¿ç”¨æ·±åº•ç™½å­—ä»¥å€åˆ† -->
          <div id="current-time-display" class="text-center bg-gray-900/50 p-2 rounded h-[42px] flex items-center justify-center min-w-[210px] text-[#e2e8f0]"></div>
        </div>
      </div>
    </div>
    <!-- è³½å­£é¸é … -->
    <div class="text-center mb-6">
      <label for="season-select" class="mr-2 font-semibold">è³½å­£é¸é …:</label>
      <select id="season-select" class="input-field rounded p-2">
        <option value="s1">S1 æ¾¤ä¹‹åœ‹</option>
        <!-- <option value="s2">S2 é¾ä¹‹åœ‹</option> -->
        <!-- æœªä¾†å¯æ“´å……å…¶ä»–è³½å­£ -->
      </select>
    </div>
    <!-- ===== ç›®æ¨™ç­‰ç´šï¼ˆå…±é³´ï¼‰ ===== -->
    <div class="card rounded-lg p-6 shadow-lg mb-6 max-w-6xl mx-auto">
      <h3 class="text-xl font-bold text-center mb-4">ç›®æ¨™ç­‰ç´š (å…±é³´)</h3>
      <!-- å›ºå®šå…­æ¬„ï¼Œç¢ºä¿å°é½Š -->
      <div id="target-levels" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-4"></div>
    </div>

    <!-- ===== éºç‰©åˆ†ä½ˆ ===== -->
    <div class="card rounded-lg p-6 shadow-lg mb-6 max-w-6xl mx-auto">
      <h3 class="text-xl font-bold text-center mb-4">éºç‰©ç­‰ç´šåˆ†ä½ˆ <span id="relic-total-display" class="text-sm font-normal text-gray-400">(0/20)</span></h3>
      <div id="relic-distribution-inputs" class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-11 gap-x-6 gap-y-4"></div>
    </div>

    <!-- ===== ä¸‰æ¬„ä¸»å…§å®¹ ===== -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- å·¦ï¼šè§’è‰²ç›®å‰ç­‰ç´š -->
      <div class="card rounded-xl p-0 shadow-lg max-h-[75vh] flex flex-col">
        <h2 class="text-2xl font-bold border-b pb-3 sticky top-0 z-10 px-6 py-3 m-0 bg-white/90 backdrop-blur border-[#cde5e8]">è§’è‰²ç›®å‰ç­‰ç´š</h2>
        <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
          <div id="level-inputs" class="pt-2"></div>
        </div>
      </div>

      <!-- ä¸­ï¼šå°æ¨è»Šï¼ˆç›®å‰åƒ…æ‰‹å‹•æ™‚ç”¢ï¼‰ -->
      <div class="card rounded-xl p-0 shadow-lg max-h-[75vh] flex flex-col">
        <h2 class="text-2xl font-bold border-b pb-3 sticky top-0 z-10 px-6 py-3 m-0 bg-white/90 backdrop-blur border-[#cde5e8]">å°æ¨è»Š</h2>
        <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
          <div id="production-inputs" class="space-y-6 mb-6"></div>
        </div>
      </div>

      <!-- å³ï¼šç´ æè³‡è¨Š + è¨ˆç®—ç¸½è¦½ -->
      <div class="flex flex-col gap-6">
        <div class="card rounded-xl p-0 shadow-lg max-h-[40vh] flex flex-col">
          <h2 class="text-2xl font-bold border-b pb-3 sticky top-0 z-10 px-6 py-3 m-0 bg-white/90 backdrop-blur border-[#cde5e8]">ç´ æè³‡è¨Š</h2>
          <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
            <div class="pt-2 mb-6 border-b border-[#e5eff1] pb-6">
              <h3 class="text-lg font-semibold text-accent mb-3">åºŠ</h3>
              <div class="flex items-center">
                <label for="bed-exp-hourly" class="w-full block text-sm font-bold">ğŸ“– æ¯å°æ™‚ç¶“é©—ç”¢é‡</label>
                <input type="number" id="bed-exp-hourly" placeholder="0" class="input-field rounded w-full p-2">
              </div>
              <div id="bed-levelup-time" class="text-xs text-gray-500 mt-2">é è¨ˆå‡ç´šæ™‚é–“: --</div>
            </div>

            <h3 class="text-lg font-semibold text-accent mb-3">ç›®å‰æŒæœ‰ç´ æ</h3>
            <div id="owned-materials" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-1 gap-4"></div>
          </div>
        </div>

        <div class="card rounded-xl p-0 shadow-lg max-h-[43.5vh] flex flex-col">
          <h2 class="text-2xl font-bold border-b pb-3 sticky top-0 z-10 px-6 py-3 m-0 bg-white/90 backdrop-blur border-[#cde5e8]">è¨ˆç®—ç¸½è¦½</h2>
          <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
            <div id="results" class="space-y-4 pt-2">
              <p class="text-gray-500 text-center py-8">æ­£åœ¨è¼‰å…¥éŠæˆ²æ•¸æ“š...</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ===== åº•éƒ¨ï¼šåŠŸèƒ½æŒ‰éˆ• ===== -->
    <footer class="text-center text-gray-500 mt-10 text-sm">
        <div class="space-x-4">
            <button id="enable-notifications-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg text-xs">å•Ÿç”¨å‡ç´šé€šçŸ¥</button>
            <button id="clear-data-btn" class="bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg text-xs">æ¸…é™¤æœ¬åœ°ç´€éŒ„</button>
        </div>
        <p class="mt-4">é‡è¦ï¼šè«‹å°‡æ‰€æœ‰ .csv æª”æ¡ˆèˆ‡æ­¤ HTML æª”æ¡ˆæ”¾åœ¨åŒä¸€å€‹è³‡æ–™å¤¾ï¼Œä¸¦é€éæœ¬åœ°ä¼ºæœå™¨ (Local Server) ç€è¦½ã€‚</p>
    </footer>
  </div>

  <script>
    /* ---------------------------------------
     * åŸºç¤è¨­å®šèˆ‡è³‡æ–™æ¨¡å‹
     * ------------------------------------- */
    const MAX_LEVEL = 200;              // è§’è‰²æœ€é«˜ç­‰ç´šä¸Šé™
    let notificationTimerId = null;     // æ¨æ’­è¨ˆæ™‚å™¨ï¼ˆé¿å…é‡è¤‡æ’ç¨‹ï¼‰

    // å·¦æ¬„ï¼šå¯è¼¸å…¥çš„ç›®å‰ç­‰ç´š
    const categories = [
      { id:'character', name:'è§’è‰²ç­‰ç´š' },
      { id:'equipment_main_weapon', name:'ä¸»æ­¦å™¨', group:'è£å‚™ç­‰ç´š' },
      { id:'equipment_off_weapon',  name:'å‰¯æ­¦å™¨', group:'è£å‚™ç­‰ç´š' },
      { id:'equipment_helmet',      name:'é ­ç›”',   group:'è£å‚™ç­‰ç´š' },
      { id:'equipment_armor',       name:'é§ç”²',   group:'è£å‚™ç­‰ç´š' },
      { id:'equipment_boots',       name:'æˆ°é´',   group:'è£å‚™ç­‰ç´š' },
      { id:'skill_combat1',         name:'æˆ°æŠ€ä¸€', group:'æŠ€èƒ½ç­‰ç´š' },
      { id:'skill_combat2',         name:'æˆ°æŠ€äºŒ', group:'æŠ€èƒ½ç­‰ç´š' },
      { id:'skill_combat3',         name:'æˆ°æŠ€ä¸‰', group:'æŠ€èƒ½ç­‰ç´š' },
      { id:'skill_combat4',         name:'æˆ°æŠ€å››', group:'æŠ€èƒ½ç­‰ç´š' },
      { id:'skill_arcane1',         name:'ç¥•æ³•ä¸€', group:'æŠ€èƒ½ç­‰ç´š' },
      { id:'skill_arcane2',         name:'ç¥•æ³•äºŒ', group:'æŠ€èƒ½ç­‰ç´š' },
      { id:'skill_arcane3',         name:'ç¥•æ³•ä¸‰', group:'æŠ€èƒ½ç­‰ç´š' },
      { id:'skill_arcane4',         name:'ç¥•æ³•å››', group:'æŠ€èƒ½ç­‰ç´š' },
      { id:'pet1', name:'å¹»ç¸ä¸€', group:'å¹»ç¸ç­‰ç´š' },
      { id:'pet2', name:'å¹»ç¸äºŒ', group:'å¹»ç¸ç­‰ç´š' },
      { id:'pet3', name:'å¹»ç¸ä¸‰', group:'å¹»ç¸ç­‰ç´š' },
      { id:'pet4', name:'å¹»ç¸å››', group:'å¹»ç¸ç­‰ç´š' },
    ];

    // é ‚éƒ¨ï¼šç›®æ¨™ç­‰ç´šï¼ˆå…±é³´ï¼‰æ¬„ä½
    const targetLevelConfig = [
      { id:'character',         name:'è§’è‰²ç­‰ç´š' },
      { id:'equipment_resonance', name:'è£å‚™å…±é³´' },
      { id:'skill_resonance',     name:'æŠ€èƒ½å…±é³´' },
      { id:'pet_resonance',       name:'å¹»ç¸å…±é³´' },
      { id:'relic_resonance',     name:'éºç‰©å…±é³´' },
      { id:'primordial_star',     name:'åŸåˆä¹‹æ˜Ÿ', readonly:true }, // å”¯è®€ï¼Œè‡ªå‹•è¨ˆç®—
    ];

    // å¯ç”¨ç´ æï¼ˆå³æ¬„ï¼‰
    const materials = {
      exp:{ name:'è§’è‰²ç¶“é©—', icon:'ğŸ“–' },
      rola:{ name:'ç¾…æ‹‰å¹£', icon:'ğŸ’°' },
      essence:{ name:'æ­·æˆ°ç²¾è¯', icon:'âœ¨' },
      sand:{ name:'æ™‚ä¹‹ç ‚', icon:'â³' },
      stoneOre:{ name:'ç²—ç…‰çŸ³', icon:'ğŸ’' },
      refiningStone:{ name:'ç²¾ç…‰çŸ³', icon:'ğŸ”¨' },
      freezeDried:{ name:'å¹»ç¸å‡ä¹¾', icon:'ğŸ–' },
    };

    // æ¨è»Šï¼ˆåªç”¨æ–¼æ›æ©Ÿæ”¶ç›Šï¼Œå…ˆä¿ç•™è­˜åˆ¥ï¼‰
    const productionSources = {
      rola:        { materialId:'rola' },
      essence:     { materialId:'essence' },
      stoneOre:    { materialId:'stoneOre' },
      sand:        { materialId:'sand' },
      freezeDried: { materialId:'freezeDried' }
    };

    // é è™•ç†å¾Œçš„ã€Œç´¯ç©æˆæœ¬è¡¨ã€å­˜æ”¾è™•
    const cumulativeCostData = {};

    // è®€æª”å¤±æ•—æ™‚çš„å‚™ç”¨æ¨¡æ“¬è³‡æ–™
    const MOCK_GAME_DATA = {
      equipmentUpgradeCosts: [
        { level:1,  cost_stone_ore:10,  cost_rola:100,  cost_refining_stone:0 },
        { level:2,  cost_stone_ore:20,  cost_rola:200,  cost_refining_stone:0 },
        { level:30, cost_stone_ore:500, cost_rola:5000, cost_refining_stone:1 },
      ],
      skillUpgradeCosts: [
        { level:1, cost_essence:50 },
        { level:2, cost_essence:75 },
        { level:3, cost_essence:100 },
      ],
      petUpgradeCosts: [
        { level:1, cost_freeze_dried:30 },
        { level:2, cost_freeze_dried:45 },
        { level:3, cost_freeze_dried:60 },
      ],
      relicUpgradeCosts: [
        { level:1, cost_sand:100, cost_rola:1000 },
        { level:2, cost_sand:150, cost_rola:1500 },
        { level:3, cost_sand:200, cost_rola:2000 },
      ],
      // è§’è‰²å‡ç´šçš„ã€Œåˆ°é”è©²ç­‰ç´šæ‰€éœ€ç´¯ç©ç¶“é©—ã€
      characterUpgradeCosts: Array.from({ length: MAX_LEVEL }, (_, i) => ({
        level: i + 1, cost_exp: Math.floor(200 * Math.pow(i + 1, 2.2))
      })),
    };
    
    // å®šç¾©ä¸åŒè³½å­£çš„ CSV æª”æ¡ˆè·¯å¾‘
    const DATA_FILES_CONFIG = {
        s1: {
            equipmentUpgradeCosts: 'equipment_upgrade_costs_s1.csv',
            skillUpgradeCosts: 'skill_upgrade_costs_s1.csv',
            petUpgradeCosts: 'pet_upgrade_costs_s1.csv',
            relicUpgradeCosts: 'relic_upgrade_costs_s1.csv',
            characterUpgradeCosts: 'character_upgrade_costs_s1.csv',
        },
        s2: {
            equipmentUpgradeCosts: 'equipment_upgrade_costs_s2.csv',
            skillUpgradeCosts: 'skill_upgrade_costs_s2.csv',
            petUpgradeCosts: 'pet_upgrade_costs_s2.csv', 
            relicUpgradeCosts: 'relic_upgrade_costs_s2.csv',
            characterUpgradeCosts: 'character_upgrade_costs_s2.csv',
        }
    };


    // è®€å– CSVï¼ˆç°¡æ˜“è§£æï¼šç¬¬ä¸€åˆ—ç‚ºæ¨™é ­ï¼‰
    async function fetchAndParseCsv(url){
      const res = await fetch(url);
      if(!res.ok) throw new Error(`ç„¡æ³•è¼‰å…¥ CSV: ${url}`);
      const text = await res.text();
      const lines = text.trim().split('\n');
      const headers = lines[0].split(',').map(h=>h.trim());
      return lines.slice(1).map(line=>{
        const values = line.split(',').map(v=>v.trim());
        const obj = {};
        headers.forEach((h,i)=>{
          const num = parseFloat(values[i]);
          obj[h] = isNaN(num) ? 0 : num;
        });
        return obj;
      });
    }

    // å°‡æˆæœ¬è³‡æ–™è½‰æˆã€Œç´¯ç©ç¸½å’Œè¡¨ã€
    function preprocessCostData(GAME_DATA){
      const dataSources = {
        equipment:  GAME_DATA.equipmentUpgradeCosts,
        skill:      GAME_DATA.skillUpgradeCosts,
        pet:        GAME_DATA.petUpgradeCosts,
        relic:      GAME_DATA.relicUpgradeCosts,
        character:  GAME_DATA.characterUpgradeCosts,
      };
      for(const type in dataSources){
        const source = dataSources[type];
        cumulativeCostData[type] = [];
        let cumulative = {};
        if(source && source.length>0){
          Object.keys(source[0]).forEach(k=>{ if(k.startsWith('cost_')) cumulative[k] = 0; });
        }
        for(let i=0;i<(source?.length||0);i++){
          const row = source[i];
          Object.keys(cumulative).forEach(k=> cumulative[k] += (row[k]||0));
          cumulativeCostData[type].push({ level: row.level, ...cumulative });
        }
      }
    }

    // å–å¾—æŒ‡å®šç­‰ç´šçš„ã€Œç´¯ç©ã€æˆæœ¬ï¼ˆè‹¥ level ä¸å­˜åœ¨ï¼Œå›å‚³æœ€è¿‘çš„ä½ç­‰ç´šï¼‰
    function getCumulativeCost(costTable, level){
      const empty = {};
      if(!costTable || costTable.length===0) return empty;
      costTable.forEach(row => Object.keys(row).forEach(k => empty[k]=0));
      delete empty.level;
      if(level<=0) return empty;
      const idx = costTable.findLastIndex(d => d.level <= level);
      const data = (idx !== -1) ? costTable[idx] : null;
      return { ...empty, ...data };
    }

    // æˆæœ¬æ¬„ä½å -> ææ–™éµåï¼ˆä¾‹ï¼šcost_stone_ore -> stoneOreï¼‰
    function getMaterialIdFromCostKey(costKey){
      let id = costKey.replace('cost_','');
      if(id==='stone') return 'stoneMat';
      return id.replace(/_([a-z])/g, m=>m[1].toUpperCase());
    }

    /* ---------------------------------------
     * DOM Readyï¼šè¼‰å…¥è³‡æ–™ -> åˆå§‹åŒ– UI -> ç¶äº‹ä»¶
     * ------------------------------------- */
    document.addEventListener('DOMContentLoaded', async ()=>{
      const containers = {
        levelInputs: document.getElementById('level-inputs'),
        ownedMaterials: document.getElementById('owned-materials'),
        productionInputs: document.getElementById('production-inputs'),
        results: document.getElementById('results'),
        targetLevels: document.getElementById('target-levels'),
        relicDistributionInputs: document.getElementById('relic-distribution-inputs'),
        currentTimeDisplay: document.getElementById('current-time-display'),
      };
      
      const seasonSelector = document.getElementById('season-select');
      
      async function loadDataForSeason(seasonId) {
          const dataFiles = DATA_FILES_CONFIG[seasonId] || DATA_FILES_CONFIG.s1;
          const loadedGameData = {};
          const missingFiles = [];

          for (const key in dataFiles) {
              try {
                  loadedGameData[key] = await fetchAndParseCsv(dataFiles[key]);
              } catch (error) {
                  console.warn(`ç„¡æ³•è¼‰å…¥ ${dataFiles[key]}ï¼Œå°‡ä½¿ç”¨æ¨¡æ“¬æ•¸æ“šã€‚`, error);
                  loadedGameData[key] = MOCK_GAME_DATA[key];
                  missingFiles.push(dataFiles[key]);
              }
          }
          return { loadedGameData, missingFiles };
      }

      async function handleSeasonChange() {
          const seasonId = seasonSelector.value;
          containers.results.innerHTML = '<p class="text-gray-500 text-center py-8">æ­£åœ¨è¼‰å…¥æ–°è³½å­£æ•¸æ“š...</p>';
          const { loadedGameData, missingFiles } = await loadDataForSeason(seasonId);
          main(loadedGameData, containers, missingFiles);
          // å„²å­˜é¸æ“‡çš„è³½å­£
          const currentData = JSON.parse(localStorage.getItem('sxstxCalculatorData')) || {};
          currentData['season-select'] = seasonId;
          localStorage.setItem('sxstxCalculatorData', JSON.stringify(currentData));

      }

      seasonSelector.addEventListener('change', handleSeasonChange);

      // åˆå§‹è¼‰å…¥
      const savedData = JSON.parse(localStorage.getItem('sxstxCalculatorData')) || {};
      seasonSelector.value = savedData['season-select'] || 's1';
      await handleSeasonChange();
    });

    /* ---------------------------------------
     * ä¸»æµç¨‹ï¼šæ¸²æŸ“ UIã€è¨ˆç®—ã€äº‹ä»¶
     * ------------------------------------- */
    function main(GAME_DATA, containers, missingFiles){
      preprocessCostData(GAME_DATA);

      // å°å·¥å…·ï¼šå»ºå…ƒç´ 
      const el = (tag, classes=[]) => {
        const n = document.createElement(tag);
        if(classes.length) n.classList.add(...classes);
        return n;
      };

      // è¼¸å…¥ç¾¤çµ„ï¼šlabel + input
      const createInputGroup = (id, labelText, placeholder, isSub=false, extraHtml='')=>{
        const wrap = el('div', isSub?['mb-4']:[]);
        const label = el('label', ['block','text-sm','font-bold','mb-2']);
        label.htmlFor = id; label.textContent = labelText;

        const input = el('input', ['input-field','rounded','w-full','p-2']);
        input.type = 'number'; input.id = id; input.placeholder = placeholder;

        wrap.append(label, input);
        if(extraHtml){ const div = el('div'); div.innerHTML = extraHtml; wrap.appendChild(div); }
        return wrap;
      };

      /* ========== æ¸²æŸ“ï¼šå·¦æ¬„ ç›®å‰ç­‰ç´š ========== */
      function renderLevelInputs(){
        const frag = document.createDocumentFragment();

        // è§’è‰²ï¼ˆç¨ç«‹ä¸€è¡Œï¼‰
        const roleTitle = el('h3',['text-lg','font-semibold','text-accent','pb-2','mb-3']);
        roleTitle.textContent = 'è§’è‰²ç­‰ç´š';
        frag.appendChild(roleTitle);
        const roleRow = el('div',['grid','grid-cols-1','gap-4','mb-4','border-b','border-[#e5eff1]','pb-6']);
        const charCat = categories.find(c=>c.id==='character');
        if(charCat) roleRow.appendChild(createInputGroup(`${charCat.id}-current`, charCat.name, 'ç›®å‰'));
        frag.appendChild(roleRow);

        // å¹»ç¸ï¼ˆä¸€è¡Œå››æ ¼ï¼‰
        const petTitle = el('h3',['text-lg','font-semibold','text-accent','pb-2','mb-3']);
        petTitle.textContent = 'å¹»ç¸ç­‰ç´š';
        frag.appendChild(petTitle);
        const petRow = el('div',['grid','grid-cols-2','sm:grid-cols-4','gap-4','mb-4','border-b','border-[#e5eff1]','pb-6']);
        categories.filter(c=>c.id.startsWith('pet')).forEach(cat=>{
          petRow.appendChild(createInputGroup(`${cat.id}-current`, cat.name, 'ç›®å‰'));
        });
        frag.appendChild(petRow);

        // è£å‚™ï¼ˆå…©æ¬„åˆ†æµï¼‰
        const equipTitle = el('h3',['text-lg','font-semibold','text-accent','pb-2','mb-3']);
        equipTitle.textContent = 'è£å‚™ç­‰ç´š';
        frag.appendChild(equipTitle);
        const equipWrap = el('div',['grid','grid-cols-2','gap-x-6','mb-4','border-b','border-[#e5eff1]','pb-6']);
        const equipCol1 = el('div'), equipCol2 = el('div');
        categories.filter(c=>c.group==='è£å‚™ç­‰ç´š').forEach((cat,i)=>{
          (i<2?equipCol1:equipCol2).appendChild(createInputGroup(`${cat.id}-current`, cat.name, 'ç›®å‰', true));
        });
        equipWrap.append(equipCol1, equipCol2);
        frag.appendChild(equipWrap);

        // æŠ€èƒ½ï¼ˆæˆ°æŠ€ / ç¥•æ³• å„ä¸€æ¬„ï¼‰
        const skillTitle = el('h3',['text-lg','font-semibold','text-accent','pb-2','mb-3']);
        skillTitle.textContent = 'æŠ€èƒ½ç­‰ç´š';
        frag.appendChild(skillTitle);
        const skillWrap = el('div',['grid','grid-cols-2','gap-x-6','mb-4','border-b','border-[#e5eff1]','pb-6']);
        const s1 = el('div'), s2 = el('div');
        categories.filter(c=>c.id.startsWith('skill_combat')).forEach(cat=> s1.appendChild(createInputGroup(`${cat.id}-current`, cat.name, 'ç›®å‰', true)));
        categories.filter(c=>c.id.startsWith('skill_arcane')).forEach(cat=> s2.appendChild(createInputGroup(`${cat.id}-current`, cat.name, 'ç›®å‰', true)));
        skillWrap.append(s1,s2);
        frag.appendChild(skillWrap);

        containers.levelInputs.appendChild(frag);
      }

      /* ========== æ¸²æŸ“ï¼šç›®æ¨™ç­‰ç´šï¼ˆå…­æ¬„ç­‰å¯¬ï¼‰ ========== */
      function renderTargetLevels(){
        containers.targetLevels.innerHTML = '';
        targetLevelConfig.forEach(t=>{
          const badge = (t.id==='character')
            ? `<div id="target-char-reachable-level" class="text-xs text-gray-500 mt-1">æœ€ä½å¯é”: --</div>` : '';
          const isReadOnly = t.readonly === true;
          const group = createInputGroup(`target-${t.id}`, t.name, isReadOnly? 'è‡ªå‹•è¨ˆç®—':'ç›®æ¨™', false, badge);

          if(isReadOnly){
            const input = group.querySelector('input');
            input.setAttribute('disabled','disabled');
            input.setAttribute('aria-readonly','true');
            const label = group.querySelector('label');
            label.insertAdjacentHTML('beforeend',
              `<span class="ml-2 text-[10px] px-1.5 py-0.5 rounded bg-amber-100 text-amber-700 align-middle">è‡ªå‹•</span>`
            );
          }

          containers.targetLevels.appendChild(group);
        });
      }

      /* ========== æ¸²æŸ“ï¼šéºç‰©åˆ†ä½ˆï¼ˆ10~20ï¼‰ ========== */
      function renderRelicDistribution(){
        for(let i=10;i<=20;i++){
          const g = createInputGroup(`relic-level-${i}`, `ç­‰ç´š ${i}`, 'æ•¸é‡');
          g.querySelector('input').classList.add('relic-dist-input');
          containers.relicDistributionInputs.appendChild(g);
        }
      }

      /* ========== æ¸²æŸ“ï¼šå³æ¬„ç´ æè¼¸å…¥ ========== */
      function renderMaterials(){
        Object.entries(materials).forEach(([id,mat])=>{
          const row = el('div',['flex','items-center']);
          const label = el('label',['w-full','block','text-sm','font-bold']);
          label.htmlFor = `owned-${id}`;
          label.textContent = `${mat.icon} ${mat.name}`;
          const input = el('input',['input-field','rounded','w-full','p-2']);
          input.type='number'; input.id=`owned-${id}`; input.placeholder='0';
          row.append(label,input);
          containers.ownedMaterials.appendChild(row);
        });
      }

      /* ========== æ¸²æŸ“ï¼šå°æ¨è»Šï¼ˆæ‰‹å‹•æ™‚ç”¢è¼¸å…¥ï¼‰ ========== */
      function renderProduction(){
        Object.entries(productionSources).forEach(([srcId,src])=>{
          const mat = materials[src.materialId];
          const wrap = el('div');
          const title = el('label',['block','text-sm','font-bold','mb-2']);
          title.textContent = `${mat.icon} ${mat.name}`;
          wrap.appendChild(title);

          const hourlyDiv = el('div');
          const small = el('label',['text-xs','text-gray-500']); small.textContent='æ™‚ç”¢é‡';
          const manual = createInputGroup(`manual-hourly-${srcId}`,'','æ‰‹å‹•è¼¸å…¥').querySelector('input');
          manual.classList.add('text-sm');
          hourlyDiv.append(small, manual.parentElement);
          wrap.appendChild(hourlyDiv);

          containers.productionInputs.appendChild(wrap);
        });
      }

      /* ========== ç¶œåˆæ¸²æŸ“å‘¼å« ========== */
      function render(){
        // æ¸…ç©ºå®¹å™¨
        Object.values(containers).forEach(c => c && (c.innerHTML=''));
        renderLevelInputs();
        renderTargetLevels();
        renderRelicDistribution();
        renderMaterials();
        renderProduction();
      }

      /* ========== ç¾åœ¨æ™‚é–“é¡¯ç¤ºï¼ˆæ¯ç§’æ›´æ–°ï¼‰ ========== */
      function updateCurrentTime(){
        const el = containers.currentTimeDisplay;
        if(!el) return;
        const now = new Date();
        el.textContent = now.toLocaleString('sv-SE', {
          year:'numeric', month:'2-digit', day:'2-digit',
          hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
        });
      }

      /* ========== éºç‰©åˆ†ä½ˆç¸½æ•¸é¡¯ç¤º ========== */
      function updateRelicTotal(){
        let total = 0;
        document.querySelectorAll('.relic-dist-input').forEach(i=> total += (parseInt(i.value)||0));
        const disp = document.getElementById('relic-total-display');
        disp.textContent = `(${total}/20)`;
        if(total !== 20 && total > 0){ disp.classList.add('text-warning'); disp.classList.remove('text-gray-400'); }
        else { disp.classList.remove('text-warning'); disp.classList.add('text-gray-400'); }
      }

        /* ========== S1 è³½å­£åˆ†æ•¸è¨ˆç®— ========== */
        function calculateSeasonScore_S1(targets){
            let score = 0;
            // è§’è‰²ç­‰ç´šï¼ˆS1 è¶…é 100 ç­‰ï¼Œæ¯ç­‰æ› 100 è³½å­£åˆ†æ•¸ï¼‰
            if(targets.character > 100) score += (targets.character - 100) * 100;
            // è£å‚™å…±é³´ï¼ˆS1 è¶…é 100 ç­‰ï¼Œæ¯ç­‰æ› 190 è³½å­£åˆ†æ•¸ï¼‰
            if(targets.equipment_resonance > 100) score += (targets.equipment_resonance - 100) * 190;
            // æŠ€èƒ½å…±é³´ï¼ˆS1 è¶…é 100 ç­‰ï¼Œæ¯ç­‰æ› 104 è³½å­£åˆ†æ•¸ï¼‰
            if(targets.skill_resonance > 100) score += (targets.skill_resonance - 100) * 104;
            // å¹»ç¸å…±é³´ï¼ˆS1 è¶…é 100 ç­‰ï¼Œæ¯ç­‰æ› 56 è³½å­£åˆ†æ•¸ï¼‰
            if(targets.pet_resonance > 100) score += (targets.pet_resonance - 100) * 56;
            // éºç‰©å…±é³´ï¼ˆS1 è¶…é 10 ç­‰ï¼Œæ¯ç­‰æ› 200 è³½å­£åˆ†æ•¸ï¼‰
            if(targets.relic_resonance > 10) score += (targets.relic_resonance - 10) * 1140;
            return score;
        }

        /* ========== S1 åŸåˆä¹‹æ˜Ÿè½‰æ› ========== */
        function convertPrimordialStar_S1(score){
            // S1 åŸåˆä¹‹æ˜Ÿæ›ç®—å…¬å¼ï¼šè³½å­£åˆ†æ•¸ / 100 + 10 å–æ•´æ•¸
            return Math.floor(score/100 + 10);
        }

        /* ========== S2 è³½å­£åˆ†æ•¸è¨ˆç®— ========== */
        function calculateSeasonScore_S2(targets){
            let score = 0;
            // è§’è‰²ç­‰ç´šï¼ˆS2 è¶…é 100 ç­‰ï¼Œæ¯ç­‰æ› 120 è³½å­£åˆ†æ•¸ï¼‰
            if(targets.character > 100) score += (targets.character - 100) * 120;
            // è£å‚™å…±é³´ï¼ˆS2 è¶…é 100 ç­‰ï¼Œæ¯ç­‰æ› 200 è³½å­£åˆ†æ•¸ï¼‰
            if(targets.equipment_resonance > 100) score += (targets.equipment_resonance - 100) * 200;
            // æŠ€èƒ½å…±é³´ï¼ˆS2 è¶…é 100 ç­‰ï¼Œæ¯ç­‰æ› 110 è³½å­£åˆ†æ•¸ï¼‰
            if(targets.skill_resonance > 100) score += (targets.skill_resonance - 100) * 110;
            // å¹»ç¸å…±é³´ï¼ˆS2 è¶…é 100 ç­‰ï¼Œæ¯ç­‰æ› 60 è³½å­£åˆ†æ•¸ï¼‰
            if(targets.pet_resonance > 100) score += (targets.pet_resonance - 100) * 60;
            // éºç‰©å…±é³´ï¼ˆS2 è¶…é 10 ç­‰ï¼Œæ¯ç­‰æ› 1200 è³½å­£åˆ†æ•¸ï¼‰
            if(targets.relic_resonance > 10) score += (targets.relic_resonance - 10) * 1200;
            return score;
        }

      /* ========== ä¸»è¨ˆç®—ï¼šè³‡æºéœ€æ±‚ / æ›æ©Ÿæ”¶ç›Š / ç¼ºå£ ========== */
      function calculate(){
        let required = {};                 // é¤Šæˆéœ€æ±‚ç¸½è¨ˆ
        let hasError = false, hasInput = false;
        const missingDataErrors = {}; // æ”¹ç‚ºç‰©ä»¶ä¾†è¿½è¹¤æ¯å€‹ç´ æçš„éŒ¯èª¤

        // è®€å–ã€Œç›®æ¨™ç­‰ç´šã€
        const targets = {};
        targetLevelConfig.forEach(t => targets[t.id] = parseInt(document.getElementById(`target-${t.id}`).value) || 0);

        // å¯é”è§’è‰²ç­‰ç´šï¼ˆæ ¹æ“šç›®æ¨™æ™‚é–“èˆ‡åºŠï¼‰
        const reachableChar = document.getElementById('target-char-reachable-level');
        const curCharLv = parseInt(document.getElementById('character-current').value) || 0;
        const ownedExp = parseInt(document.getElementById('owned-exp')?.value) || 0; // å¯è‡ªè¡ŒåŠ ä¸€å€‹ã€Œç›®å‰å·²ç´¯ç©ç¶“é©—ã€æ¬„ä½
        const bedExpHourly = parseFloat(document.getElementById('bed-exp-hourly').value) || 0;
        const targetTimeStr = document.getElementById('target-time').value;

        let reachableCharLevel = curCharLv;
        if (targetTimeStr && cumulativeCostData['character']) {
          const hours = Math.max(0, (new Date(targetTimeStr).getTime() - Date.now()) / 36e5);
          const currentCum = getCumulativeCost(cumulativeCostData['character'], curCharLv - 1).cost_exp;
          const totalExp = currentCum + ownedExp + (bedExpHourly * hours);
          const idx = cumulativeCostData['character'].findLastIndex(d => d.cost_exp <= totalExp);
          reachableCharLevel = (idx !== -1) ? cumulativeCostData['character'][idx].level : curCharLv;
        }
        reachableChar.textContent = `æœ€ä½å¯é”: ${reachableCharLevel > 0 ? reachableCharLevel : '--'}`;

        // TODO: è‡ªå‹•è¨ˆç®—ã€ŒåŸåˆä¹‹æ˜Ÿã€ç­‰ç´š
        const primordialStarInput = document.getElementById('target-primordial_star');
        if (primordialStarInput) {
            const relicRes = targets.relic_resonance || 0;
            // æ ¹æ“šè³½å­£è¨ˆç®—è³½å­£åˆ†æ•¸   
            let score = 0;
            if (document.getElementById('season-select').value === 's1') {
                score = calculateSeasonScore_S1(targets);
            }
            else if (document.getElementById('season-select').value === 's2') {
                score = calculateSeasonScore_S2(targets);
            }

            // æ ¹æ“šè³½å­£å°‡è³½å­£åˆ†æ•¸æ›ç®—åŸåˆä¹‹æ˜Ÿ
            if (document.getElementById('season-select').value === 's1') {
                targets.primordial_star = convertPrimordialStar_S1(score);
            }
            else if (document.getElementById('season-select').value === 's2') {
                // S2 çš„æ›ç®—å…¬å¼å¾…ç¢ºèªï¼Œæš«æ™‚å…ˆç”¨ S1 çš„
                targets.primordial_star = convertPrimordialStar_S1(score);
            }
            primordialStarInput.value = targets.primordial_star;
            document.getElementById('target-primordial_star').value = targets.primordial_star;

        }

        // éºç‰©æˆæœ¬ï¼ˆéœ€è¦ 20 ä»¶ï¼‰
        const targetRelicResonance = targets.relic_resonance;
        let relicCount = 0;
        for(let i=10;i<=20;i++){
          const count = parseInt(document.getElementById(`relic-level-${i}`).value) || 0;
          if(count>0) hasInput = true;
          relicCount += count;

          for(let j=0;j<count;j++){
            const current = i;
            const finalTarget = Math.max(current, targetRelicResonance);
            if(finalTarget>current){
              const costTable = cumulativeCostData.relic;
              const sourceTable = GAME_DATA.relicUpgradeCosts;
              let missing = false;
              for(let lvl=current; lvl<finalTarget; lvl++){
                if(!sourceTable.find(d=>d.level===lvl)){ 
                    const errorMsg = `æ•¸æ“šç¼ºå¤±: éºç‰©ç¼ºå°‘ ${lvl} ç´š`;
                    // éºç‰©å‡ç´šæœƒå½±éŸ¿ sand å’Œ rola
                    if (!missingDataErrors.sand) missingDataErrors.sand = errorMsg;
                    if (!missingDataErrors.rola) missingDataErrors.rola = errorMsg;
                    missing=true; 
                    break; 
                }
              }
              if(!missing && costTable){
                const start = getCumulativeCost(costTable, current - 1);
                const end   = getCumulativeCost(costTable, finalTarget - 1);
                Object.keys(end).forEach(key=>{
                  if(key.startsWith('cost_')){
                    const matId = getMaterialIdFromCostKey(key);
                    const startVal = start[key] || 0;
                    required[matId] = (required[matId]||0) + (end[key] - startVal);
                  }
                });
              }
            }
          }
        }
        if(relicCount>0 && relicCount!==20) hasError = true;

        // è§’è‰² / è£å‚™ / æŠ€èƒ½ / å¹»ç¸æˆæœ¬
        categories.forEach(cat=>{
          const current = parseInt(document.getElementById(`${cat.id}-current`).value) || 0;
          if(current>0) hasInput = true;

          let targetRes = 0;
          if (cat.id === 'character') targetRes = targets.character;
          else if (cat.id.startsWith('equipment_')) targetRes = targets.equipment_resonance;
          else if (cat.id.startsWith('skill_'))     targetRes = targets.skill_resonance;
          else if (cat.id.startsWith('pet'))        targetRes = targets.pet_resonance;

          const finalTarget = Math.max(current, targetRes);
          if(finalTarget>current){
            let costTable, sourceTable, itemName, affectedMats = [];
            if (cat.id.startsWith('equipment_')) { 
                costTable=cumulativeCostData.equipment; 
                sourceTable=GAME_DATA.equipmentUpgradeCosts; 
                itemName='è£å‚™';
                affectedMats = ['stoneOre', 'rola', 'refiningStone'];
            }
            else if (cat.id.startsWith('skill_')) { 
                costTable=cumulativeCostData.skill;     
                sourceTable=GAME_DATA.skillUpgradeCosts;     
                itemName='æŠ€èƒ½';
                affectedMats = ['essence'];
            }
            else if (cat.id.startsWith('pet'))    { 
                costTable=cumulativeCostData.pet;       
                sourceTable=GAME_DATA.petUpgradeCosts;       
                itemName='å¹»ç¸';
                affectedMats = ['freezeDried'];
            }
            else { 
                costTable=cumulativeCostData[cat.id]; 
                sourceTable=GAME_DATA.characterUpgradeCosts; 
                itemName='è§’è‰²';
                affectedMats = ['exp'];
            }

            let missing=false;
            if(sourceTable){
              for(let lvl=current; lvl<finalTarget; lvl++){
                if(!sourceTable.find(d=>d.level===lvl)){ 
                    const errorMsg = `æ•¸æ“šç¼ºå¤±: ${itemName}ç¼ºå°‘ ${lvl} ç´š`;
                    affectedMats.forEach(matId => {
                        if (!missingDataErrors[matId]) missingDataErrors[matId] = errorMsg;
                    });
                    missing=true; 
                    break; 
                }
              }
            }
            if(!missing && costTable){
              const start = getCumulativeCost(costTable, current - 1);
              const end   = getCumulativeCost(costTable, finalTarget - 1);
              Object.keys(end).forEach(key=>{
                if(key.startsWith('cost_')){
                  const matId = getMaterialIdFromCostKey(key);
                  const startVal = start[key] || 0;
                  required[matId] = (required[matId]||0) + (end[key] - startVal);
                }
              });
            }
          }
        });

        // ç•°å¸¸å›å ±
        if (hasError){
          containers.results.innerHTML = '<p class="text-warning text-center py-4">è¼¸å…¥æœ‰èª¤ (ä¾‹å¦‚éºç‰©ç¸½æ•¸ä¸ç‚º20)ï¼Œè«‹æª¢æŸ¥ã€‚</p>';
          return;
        }
        if(!hasInput){ renderResults({}, {}, {}, {}, missingDataErrors); return; }

        // æ›æ©Ÿæ”¶ç›Šï¼ˆä¾ç›®æ¨™æ™‚é–“ï¼›æœ¬ç‰ˆåªä½¿ç”¨ã€Œæ‰‹å‹•æ™‚ç”¢ã€ï¼‰
        const gainsFromTime = {};
        if(targetTimeStr){
          const hours = Math.max(0, (new Date(targetTimeStr).getTime() - Date.now()) / 36e5);
          for(const srcId in productionSources){
            const manual = parseFloat(document.getElementById(`manual-hourly-${srcId}`)?.value) || 0;
            gainsFromTime[productionSources[srcId].materialId] =
              (gainsFromTime[productionSources[srcId].materialId]||0) + Math.floor(manual * hours);
          }
          const bedPerHour = parseFloat(document.getElementById('bed-exp-hourly').value) || 0;
          if(bedPerHour>0) gainsFromTime['exp'] = (gainsFromTime['exp']||0) + Math.floor(bedPerHour * hours);
        }

        // ç¼ºå£ = éœ€æ±‚ - (æŒæœ‰ + æ›æ©Ÿ)
        const deficit = {};
        for(const matId in materials){
          const need = required[matId] || 0;
          const owned = parseInt(document.getElementById(`owned-${matId}`)?.value) || 0;
          const gained = gainsFromTime[matId] || 0;
          deficit[matId] = Math.max(0, need - owned - gained);
        }

        // æ›´æ–°å‡ç´šæ™‚é–“èˆ‡é€šçŸ¥
        updateLevelUpTimeAndNotification(curCharLv, ownedExp, parseFloat(document.getElementById('bed-exp-hourly').value)||0);

        // è¼¸å‡ºçµæœ
        renderResults(required, {}, gainsFromTime, deficit, missingDataErrors);
      }

      /* ========== å‡ç´šæ™‚é–“ + æ¨æ’­æ’ç¨‹ ========== */
      function updateLevelUpTimeAndNotification(currentLevel, ownedExp, bedExpHourly){
        const disp = document.getElementById('bed-levelup-time');
        if(notificationTimerId){ clearTimeout(notificationTimerId); notificationTimerId = null; }
        if (bedExpHourly <= 0 || currentLevel >= MAX_LEVEL) { disp.textContent = 'é è¨ˆå‡ç´šæ™‚é–“: --'; return; }
        const nextCumData = cumulativeCostData['character'].find(d => d.level === currentLevel);
        const curCumData = getCumulativeCost(cumulativeCostData['character'], currentLevel - 1);
        if (!nextCumData) { disp.textContent = 'å·²é”æœ€é«˜ç­‰ç´š'; return; }
        
        const nextLvlExpCost = nextCumData.cost_exp - curCumData.cost_exp;
        const expNeeded = Math.max(0, nextLvlExpCost - (Number(ownedExp)||0));
        let levelupTs = NaN;

        if(expNeeded <= 0){
          disp.textContent = 'é è¨ˆå‡ç´šæ™‚é–“: å¯ç«‹å³å‡ç´š';
        }else{
          const ratePerHour = Number(bedExpHourly);
          if(!Number.isFinite(ratePerHour) || ratePerHour<=0){
            disp.textContent = 'é è¨ˆå‡ç´šæ™‚é–“: è«‹å…ˆè¼¸å…¥åºŠçš„æ¯å°æ™‚ç¶“é©—ç”¢é‡';
          }else{
            const ratePerSec = ratePerHour / 3600;
            const secondsNeeded = Math.ceil(expNeeded / ratePerSec);
            const minutesNeeded = Math.ceil(secondsNeeded / 60);
            levelupTs = Date.now() + minutesNeeded * 60 * 1000;
            const timeStr = new Date(levelupTs).toLocaleString('zh-TW', {
              year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'
            });
            disp.textContent = `é è¨ˆå‡ç´šæ™‚é–“: ${timeStr}ï¼ˆç´„ ${minutesNeeded.toLocaleString()} åˆ†é˜ï¼‰`;
          }
        }

        if ('Notification' in window && Notification.permission === 'granted') {
          if (bedExpHourly > 0 && expNeeded > 0 && Number.isFinite(levelupTs) && levelupTs > Date.now()) {
            const alignedLvTs = Math.ceil(levelupTs / 60000) * 60000;
            const notifyAt = alignedLvTs - 3 * 60 * 1000;
            const delay = notifyAt - Date.now();
            if (delay > 0) {
              const MAX_DELAY = 0x7fffffff; // ~24.8 å¤©
              const schedule = (ms)=>{
                if(ms > MAX_DELAY){
                  notificationTimerId = setTimeout(()=>schedule(ms - MAX_DELAY), MAX_DELAY);
                }else{
                  notificationTimerId = setTimeout(()=>{
                    new Notification('æ–åŠå‚³èªªæé†’', {
                      body:`æ‚¨çš„è§’è‰²ç´„ 3 åˆ†é˜å¾Œå¯å‡ç´šè‡³ ${currentLevel + 1} ç´šï¼`,
                      icon:'https://placehold.co/192x192/31c9be/ffffff?text=LV'
                    });
                    notificationTimerId = null;
                  }, ms);
                }
              };
              schedule(delay);
            }
          }
        }
      }

      /* ========== çµæœè¼¸å‡ºï¼ˆå³ä¸‹å¡ç‰‡ï¼‰ ========== */
      function renderResults(req, prodCost, gains, deficit, materialErrors = {}){
        let html = '';
        if (missingFiles.length > 0){
          html += `<div class="bg-yellow-900/50 border-l-4 border-yellow-400 text-yellow-300 p-3 rounded-lg mb-4 text-sm">
                    <h4 class="font-bold">æ³¨æ„</h4>
                    <p>ç„¡æ³•è¼‰å…¥ä»¥ä¸‹æ•¸æ“šæª”æ¡ˆï¼Œå·²ä½¿ç”¨æ¨¡æ“¬æ•¸æ“šï¼š<br>${missingFiles.join(', ')}</p>
                   </div>`;
        }
        
        const fmt = n => n.toLocaleString();
        const displayOrder = ['rola', 'essence', 'sand', 'stoneOre', 'freezeDried'];

        const grid = el('div', ['grid', 'grid-cols-1', 'md:grid-cols-2', 'gap-4']);
        
        displayOrder.forEach(matId => {
            const mat = materials[matId];
            const card = el('div', ['p-4', 'rounded-lg', 'result-item']);
            let cardContent = `
                <div class="flex justify-between items-center mb-2">
                    <h4 class="font-bold text-gold flex items-center">
                        <span class="text-2xl mr-2">${mat.icon}</span>
                        <span>${mat.name}</span>
                    </h4>
                </div>`;

            if (materialErrors[matId]) {
                cardContent += `<div class="text-warning text-sm font-semibold">${materialErrors[matId]}</div>`;
            } else {
                const requiredAmount = req[matId] || 0;
                const deficitAmount = deficit[matId] || 0;
                const neededText = deficitAmount > 0 
                    ? `<strong class="text-warning">-${fmt(deficitAmount)}</strong>` 
                    : '<span class="text-green-400">å……è¶³</span>';

                cardContent += `
                    <div class="space-y-1 text-sm">
                        <div class="flex justify-between"><span>ç¸½å…±éœ€è¦:</span> <strong>${fmt(requiredAmount)}</strong></div>
                        <div class="flex justify-between"><span>é‚„ç¼ºå°‘:</span> ${neededText}</div>
                    </div>`;
            }
            card.innerHTML = cardContent;
            grid.appendChild(card);
        });
        
        containers.results.innerHTML = ''; // æ¸…ç©º
        containers.results.appendChild(grid);

        // å¦‚æœæ²’æœ‰ä»»ä½•è¼¸å…¥ï¼Œé¡¯ç¤ºæç¤º
        if(Object.keys(req).length === 0 && Object.keys(deficit).length === 0 && Object.keys(materialErrors).length === 0) {
            containers.results.innerHTML = html + '<p class="text-gray-500 text-center py-8">è«‹è¼¸å…¥è³‡æ–™ä»¥è‡ªå‹•è¨ˆç®—ã€‚</p>';
        } else if (html) {
            containers.results.insertAdjacentHTML('afterbegin', html);
        }
      }

      /* ========== äº‹ä»¶ç¶å®š ========== */
      function setupEventListeners(){
        // ä»»ä¸€æ•¸å€¼/æ™‚é–“æ”¹è®Šå°±é‡æ–°è¨ˆç®—
        document.body.addEventListener('input', e=>{
          const t = e.target;
          if (t.matches('input[type=number], input[type=datetime-local]')) {
            if (t.classList.contains('relic-dist-input')) updateRelicTotal();
            calculate();
            saveData();
          }
        });

        // å•Ÿç”¨é€šçŸ¥
        const notifBtn = document.getElementById('enable-notifications-btn');
        if('Notification' in window){
          notifBtn.addEventListener('click', ()=>{
            Notification.requestPermission().then(p=>{
              if(p==='granted'){
                notifBtn.textContent = 'é€šçŸ¥å·²å•Ÿç”¨';
                notifBtn.disabled = true;
                new Notification('é€šçŸ¥å·²å•Ÿç”¨',{ body:'è§’è‰²å‡ç´šå‰ 3 åˆ†é˜å°‡æé†’æ‚¨ï¼' });
              }else{
                notifBtn.textContent = 'é€šçŸ¥è¢«æ‹’çµ•'; notifBtn.disabled = true;
              }
            });
          });
        }else{
          notifBtn.textContent = 'ç€è¦½å™¨ä¸æ”¯æ´é€šçŸ¥'; notifBtn.disabled = true;
        }
        
        // æ¸…é™¤æœ¬åœ°ç´€éŒ„
        const clearBtn = document.getElementById('clear-data-btn');
        clearBtn.addEventListener('click', ()=>{
            if(confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰å·²å„²å­˜çš„æœ¬åœ°ç´€éŒ„å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚')){
                localStorage.removeItem('sxstxCalculatorData');
                location.reload();
            }
        });
      }
      
      /**
       * @description å°‡æ‰€æœ‰è¼¸å…¥æ¬„ä½çš„è³‡æ–™å„²å­˜åˆ° localStorage
       */
      function saveData() {
        const data = {};
        document.querySelectorAll('input[type=number], input[type=datetime-local], select').forEach(input => {
            if (input.id) {
                data[input.id] = input.value;
            }
        });
        localStorage.setItem('sxstxCalculatorData', JSON.stringify(data));
      }

      /**
       * @description å¾ localStorage è®€å–è³‡æ–™ä¸¦å¡«å…¥æ¬„ä½
       */
      function loadData() {
        const savedData = localStorage.getItem('sxstxCalculatorData');
        if (savedData) {
            const data = JSON.parse(savedData);
            Object.keys(data).forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.value = data[id];
                }
            });
        }
      }

      // ---- å•Ÿå‹•æµç¨‹ ----
      render();
      setupEventListeners();
      loadData();
      updateRelicTotal();
      setInterval(updateCurrentTime, 1000);
      updateCurrentTime();
      calculate(); // åˆå§‹åŒ–è¨ˆç®—ä¸€æ¬¡
    }
  </script>
</body>
</html>

