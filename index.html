<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>杖劍傳說 素材計算機</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
    body {
        font-family: 'Noto Sans TC', sans-serif;
        background: linear-gradient(180deg, #f5fafb 0%, #e6f3f4 100%);
        color: #1e293b; /* 深藍灰文字 */
    }

    .card {
        background: #ffffffd9; /* 半透明白卡片 */
        border: 1px solid #cde5e8;
        box-shadow: 0 2px 8px rgba(38, 115, 119, 0.15);
        border-radius: 10px;
    }

    .input-field {
        background-color: #f7fbfc;
        color: #1e293b;
        border: 1px solid #b6d7da;
        transition: border-color 0.25s, box-shadow 0.25s, background-color 0.25s;
    }

    .input-field:focus {
        border-color: #2cb5ab;
        box-shadow: 0 0 6px rgba(44, 181, 171, 0.4);
        outline: none;
        background-color: #f0fafa;
    }

    .input-field:disabled {
        background-color: #eef3f4;
        color: #94a3b8;
        border-color: #cbd5e1;
        cursor: not-allowed;
    }

    .btn-primary {
        background: linear-gradient(135deg, #31c9be 0%, #1a9e95 100%);
        color: #fffef8;
        border: 1px solid #21b8ac;
        box-shadow: 0 2px 6px rgba(34, 180, 168, 0.25);
        transition: background 0.3s, transform 0.15s;
    }

    .btn-primary:hover {
        background: linear-gradient(135deg, #45dfd3 0%, #23b7ac 100%);
        transform: translateY(-2px);
    }

    .result-item {
        background-color: #fffdf5;
        border-left: 4px solid #f48b45; /* 成本／缺口：橘金 */
        box-shadow: inset 0 0 8px rgba(244, 139, 69, 0.2);
    }

    .info-item {
        background-color: #f0faf9;
        border-left: 4px solid #2cb5ab; /* 資訊：青綠 */
        box-shadow: inset 0 0 8px rgba(44, 181, 171, 0.15);
    }

    .cost-item {
        background-color: #fffbee;
        border-left: 4px solid #facc15; /* 黃金亮邊 */
        box-shadow: inset 0 0 8px rgba(249, 209, 98, 0.2);
    }

    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
        opacity: 0.4;
    }

    /* 滾動條 */
    .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #f2f8f9; }
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #b3dede 0%, #89cfcf 100%);
        border-radius: 4px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, #6dcacb 0%, #4fbebf 100%);
    }

    /* 標題字色與重點色 */
    h1, h2, h3, h4 {
        color: #165f63; /* 深青標題 */
        text-shadow: 0 1px 2px rgba(22, 95, 99, 0.15);
    }
    .text-accent { color: #1fb7ad; }
    .text-gold { color: #d4a418; }
    .text-warning { color: #d65a2d; }

    /* 卡片 hover 效果 */
    .card:hover {
        box-shadow: 0 4px 14px rgba(43, 184, 172, 0.25);
        border-color: #21b8ac;
        transform: translateY(-2px);
        transition: all 0.25s ease;
    }
</style>


</head>
<body class="p-4 lg:p-6">

    <div class="w-full max-w-7xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold ">杖劍傳說 素材計算機</h1>
        </header>

        <div class="card rounded-lg p-4 shadow-lg mb-6 max-w-lg mx-auto">
            <div class="flex items-center justify-center gap-x-6">
                <div>
                    <h3 class="text-lg font-semibold text-center mb-2">目標時間</h3>
                    <input type="datetime-local" id="target-time" class="input-field rounded w-full py-2 px-3">
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-center mb-2">現在時間</h3>
                    <div id="current-time-display" class="text-center bg-gray-900/50 p-2 rounded h-[42px] flex items-center justify-center min-w-[210px]">
                        <!-- JS will populate this -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card rounded-lg p-6 shadow-lg mb-6 max-w-6xl mx-auto">
            <h3 class="text-xl font-bold text-center mb-4">目標等級 (共鳴)</h3>
            <div id="target-levels" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-4">
                <!-- JS will populate this -->
            </div>
        </div>
        
        <div class="card rounded-lg p-6 shadow-lg mb-6 max-w-6xl mx-auto">
            <h3 class="text-xl font-bold text-center mb-4">遺物等級分佈 <span id="relic-total-display" class="text-sm font-normal text-gray-400">(0/20)</span></h3>
            <div id="relic-distribution-inputs" class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-11 gap-x-6 gap-y-4">
                <!-- JS will populate this -->
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <div class="card rounded-xl p-0 shadow-lg max-h-[75vh] flex flex-col">
                <!-- 標題：sticky + 淺色背景 + 柔和邊線 -->
                <h2
                    class="text-2xl font-bold border-b pb-3 sticky top-0 z-10
                        px-6 py-3 m-0
                        bg-white/90 backdrop-blur
                        border-[#cde5e8] text-[#165f63]">
                    角色目前等級
                </h2>

                <!-- 內容：只有這層滾動；移除重複的 max-h，避免雙重捲動 -->
                <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
                    <div id="level-inputs" class="pt-2"></div>
                </div>
            </div>


            
            <div class="card rounded-xl p-0 shadow-lg max-h-[75vh] flex flex-col">
                <h2
                    class="text-2xl font-bold border-b pb-3 sticky top-0 z-10
                        px-6 py-3 m-0
                        bg-white/90 backdrop-blur
                        border-[#cde5e8] text-[#165f63]">
                    小推車
                </h2>

                <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
                    <div id="production-inputs" class="space-y-6 mb-6"></div>
                    <h3 class="text-lg font-semibold pt-4 border-t border-[#e5eff1] text-[#165f63]">全域加成 (%)</h3>
                    <div id="global-bonuses" class="grid grid-cols-3 gap-4 mt-4"></div>
                </div>
            </div>


            <div class="flex flex-col gap-6">
                <div class="card rounded-xl p-0 shadow-lg max-h-[40vh] flex flex-col">
                    <h2
                        class="text-2xl font-bold border-b pb-3 sticky top-0 z-10
                            px-6 py-3 m-0
                            bg-white/90 backdrop-blur
                            border-[#cde5e8] text-[#165f63]">
                        素材資訊
                    </h2>

                    <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
                        <div class="pt-2 mb-6 border-b border-[#e5eff1] pb-6">
                        <h3 class="text-lg font-semibold text-[#2cb5ab] mb-3">床</h3>
                        <div class="flex items-center">
                            <label for="bed-exp-hourly" class="w-full block text-sm font-bold">📖 每小時經驗產量</label>
                            <input type="number" id="bed-exp-hourly" placeholder="0" class="input-field rounded w-full p-2">
                        </div>
                        <div id="bed-levelup-time" class="text-xs text-gray-500 mt-2">預計升級時間: --</div>
                        </div>

                        <h3 class="text-lg font-semibold text-[#2cb5ab] mb-3">目前持有素材</h3>
                        <div id="owned-materials" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-1 gap-4"></div>
                    </div>
                </div>

                <div class="card rounded-xl p-0 shadow-lg max-h-[43.5vh] flex flex-col">
                    <h2
                        class="text-2xl font-bold border-b pb-3 sticky top-0 z-10
                            px-6 py-3 m-0
                            bg-white/90 backdrop-blur
                            border-[#cde5e8] text-[#165f63]">
                        計算總覽
                    </h2>

                    <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
                        <div id="results" class="space-y-4 pt-2">
                        <p class="text-gray-500 text-center py-8">正在載入遊戲數據...</p>
                        </div>
                    </div>
                </div>

            </div>
        </div>
        
        <footer class="text-center text-gray-500 mt-10 text-sm">
            <p>重要：請將所有 .csv 檔案與此 HTML 檔案放在同一個資料夾，並透過本地伺服器 (Local Server) 瀏覽。</p>
            <button id="enable-notifications-btn" class="mt-4 bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg text-xs">啟用升級通知</button>
        </footer>
    </div>

    <script>
        // --- 核心應用程式設定 (Core Application Settings) ---
        const MAX_LEVEL = 200; // 最高等級上限
        let notificationTimerId = null; // 用於存放通知的計時器ID

        // 定義所有需要輸入目前等級的項目，用於生成左側欄位
        const categories = [
            { id: 'character', name: '角色等級' },
            { id: 'equipment_main_weapon', name: '主武器', group: '裝備等級' },
            { id: 'equipment_off_weapon', name: '副武器', group: '裝備等級' },
            { id: 'equipment_helmet', name: '頭盔', group: '裝備等級' },
            { id: 'equipment_armor', name: '鎧甲', group: '裝備等級' },
            { id: 'equipment_boots', name: '戰靴', group: '裝備等級' },
            { id: 'skill_combat1', name: '戰技一', group: '技能等級' },
            { id: 'skill_combat2', name: '戰技二', group: '技能等級' },
            { id: 'skill_combat3', name: '戰技三', group: '技能等級' },
            { id: 'skill_combat4', name: '戰技四', group: '技能等級' },
            { id: 'skill_arcane1', name: '祕法一', group: '技能等級' },
            { id: 'skill_arcane2', name: '祕法二', group: '技能等級' },
            { id: 'skill_arcane3', name: '祕法三', group: '技能等級' },
            { id: 'skill_arcane4', name: '祕法四', group: '技能等級' },
            { id: 'pet1', name: '幻獸一', group: '幻獸等級' },
            { id: 'pet2', name: '幻獸二', group: '幻獸等級' },
            { id: 'pet3', name: '幻獸三', group: '幻獸等級' },
            { id: 'pet4', name: '幻獸四', group: '幻獸等級' },
        ];

        // 定義頂部的目標等級設定欄位
        const targetLevelConfig = [
            { id: 'character', name: '角色等級' },
            { id: 'equipment_resonance', name: '裝備共鳴' },
            { id: 'skill_resonance', name: '技能共鳴' },
            { id: 'pet_resonance', name: '幻獸共鳴' },
            { id: 'relic_resonance', name: '遺物共鳴' },
        ];

        // 定義所有遊戲內的素材及其圖示
        const materials = {
            exp: { name: '角色經驗', icon: '📖' },
            rola: { name: '羅拉幣', icon: '💰' },
            wood: { name: '木頭', icon: '🪵' },
            stoneMat: { name: '石頭', icon: '🪨' },
            essence: { name: '歷戰精華', icon: '✨' },
            sand: { name: '時之砂', icon: '⏳' },
            stoneOre: { name: '粗煉石', icon: '💎' },
            refiningStone: { name: '精煉石', icon: '🔨' },
            freezeDried: { name: '幻獸凍乾', icon: '🍖' },
        };

        // 定義推車可生產的資源及其基礎產量公式
        const productionSources = {
            // TODO: [遊戲數據] 此處為各資源的基礎產量公式，請根據遊戲實際情況修改
            rola: { materialId: 'rola', baseProd: (lv) => 100 * Math.pow(lv, 1.5) },
            wood: { materialId: 'wood', baseProd: (lv) => 120 * Math.pow(lv, 1.45) },
            stoneMat: { materialId: 'stoneMat', baseProd: (lv) => 110 * Math.pow(lv, 1.48) },
            essence: { materialId: 'essence', baseProd: (lv) => 50 * Math.pow(lv, 1.6) },
            stoneOre: { materialId: 'stoneOre', baseProd: (lv) => 40 * Math.pow(lv, 1.65) },
            sand: { materialId: 'sand', baseProd: (lv) => 20 * Math.pow(lv, 1.3) },
            freezeDried: { materialId: 'freezeDried', baseProd: (lv) => 30 * Math.pow(lv, 1.4) }
        };

        // 定義全域加成的項目
        const globalBonuses = {
            map: { name: '推圖進度' },
            relic: { name: '古遺物' },
            pass: { name: '月卡' }
        };

        // 用於儲存預處理後的累積成本數據
        const cumulativeCostData = {};
        
        // 內建的備用模擬數據，當 CSV 檔案載入失敗時使用
        const MOCK_GAME_DATA = {
            // TODO: [模擬數據] 以下為 CSV 讀取失敗時的備用數據
            productionUpgradeCosts: [ { level: 1, cost_wood: 100, cost_stone: 100, cost_rola: 500 }, { level: 2, cost_wood: 200, cost_stone: 200, cost_rola: 1000 }, { level: 3, cost_wood: 400, cost_stone: 400, cost_rola: 2000 }, ],
            equipmentUpgradeCosts: [ { level: 1, cost_stone_ore: 10, cost_rola: 100, cost_refining_stone: 0 }, { level: 2, cost_stone_ore: 20, cost_rola: 200, cost_refining_stone: 0 }, { level: 30, cost_stone_ore: 500, cost_rola: 5000, cost_refining_stone: 1 }, ],
            skillUpgradeCosts: [ { level: 1, cost_essence: 50 }, { level: 2, cost_essence: 75 }, { level: 3, cost_essence: 100 }, ],
            petUpgradeCosts: [ { level: 1, cost_freeze_dried: 30 }, { level: 2, cost_freeze_dried: 45 }, { level: 3, cost_freeze_dried: 60 }, ],
            relicUpgradeCosts: [ { level: 1, cost_sand: 100, cost_rola: 1000 }, { level: 2, cost_sand: 150, cost_rola: 1500 }, { level: 3, cost_sand: 200, cost_rola: 2000 }, ],
            characterUpgradeCosts: Array.from({ length: MAX_LEVEL }, (_, i) => ({ level: i + 1, cost_exp: Math.floor(200 * Math.pow(i + 1, 2.2)) })),
        };

        /**
         * @description 從指定的 URL 獲取並解析 CSV 檔案。
         * @param {string} url - CSV 檔案的路徑。
         * @returns {Promise<Array<Object>>} - 解析後的物件陣列。
         */
        async function fetchAndParseCsv(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`無法載入 CSV 檔案: ${url}`);
            }
            const csvText = await response.text();
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            return lines.slice(1).map(line => {
                const values = line.split(',').map(v => v.trim());
                const obj = {};
                headers.forEach((header, i) => {
                    const value = parseFloat(values[i]);
                    obj[header] = isNaN(value) ? 0 : value;
                });
                return obj;
            });
        }

        /**
         * @description 預處理 GAME_DATA 中的成本數據，轉換為累積成本表。
         * @param {Object} GAME_DATA - 包含所有從 CSV 或模擬數據來的成本資料。
         */
        function preprocessCostData(GAME_DATA) {
            const dataSources = {
                equipment: GAME_DATA.equipmentUpgradeCosts, skill: GAME_DATA.skillUpgradeCosts, pet: GAME_DATA.petUpgradeCosts,
                relic: GAME_DATA.relicUpgradeCosts, production: GAME_DATA.productionUpgradeCosts,
                character: GAME_DATA.characterUpgradeCosts,
            };
            // TODO: [計算] 此迴圈處理所有從 CSV 讀取的數據，將其轉換為計算機內部使用的「累積成本」格式。
            for (const type in dataSources) {
                const source = dataSources[type];
                cumulativeCostData[type] = [];
                let cumulative = {};
                if (source && source.length > 0) { Object.keys(source[0]).forEach(key => { if (key.startsWith('cost_')) cumulative[key] = 0; }); }
                for (let i = 0; i < source.length; i++) {
                    const levelData = source[i];
                    Object.keys(cumulative).forEach(key => { cumulative[key] += (levelData[key] || 0); });
                    cumulativeCostData[type].push({ level: levelData.level, ...cumulative });
                }
            }
        }

        /**
         * @description 從指定的累積成本表中，獲取某個等級的總成本。
         * @param {Array} costTable - 預處理過的累積成本表。
         * @param {number} level - 想要查詢的等級。
         * @returns {Object} 包含該等級所有累積成本的物件。
         */
        function getCumulativeCost(costTable, level) {
            // TODO: [計算] 這是獲取累積經驗/資源的核心邏輯。
            const emptyCost = {};
            if (!costTable || costTable.length === 0) return emptyCost;
            costTable.forEach(row => {
                Object.keys(row).forEach(key => emptyCost[key] = 0);
            });
            delete emptyCost.level;
            if (level <= 0) return emptyCost;
            const index = costTable.findLastIndex(d => d.level <= level);
            const data = (index !== -1) ? costTable[index] : null;
            return { ...emptyCost, ...data };
        }

        /**
         * @description 將 CSV 標頭中的成本鍵名 (如 cost_stone_ore) 轉換為 materials 物件中的鍵名 (stoneOre)。
         * @param {string} costKey - 成本鍵名。
         * @returns {string} 轉換後的材料 ID。
         */
        function getMaterialIdFromCostKey(costKey) {
            let matId = costKey.replace('cost_', '');
            if (matId === 'stone') return 'stoneMat';
            return matId.replace(/_([a-z])/g, g => g[1].toUpperCase());
        }

        // 當整個網頁文件（DOM）載入完成後，開始執行主程式
        document.addEventListener('DOMContentLoaded', async () => {
            const containers = {
                levelInputs: document.getElementById('level-inputs'), ownedMaterials: document.getElementById('owned-materials'),
                productionInputs: document.getElementById('production-inputs'), globalBonuses: document.getElementById('global-bonuses'),
                results: document.getElementById('results'), targetLevels: document.getElementById('target-levels'),
                relicDistributionInputs: document.getElementById('relic-distribution-inputs'),
                currentTimeDisplay: document.getElementById('current-time-display'),
            };
            const dataFiles = {
                productionUpgradeCosts: 'production_upgrade_costs.csv',
                equipmentUpgradeCosts: 'equipment_upgrade_costs.csv',
                skillUpgradeCosts: 'skill_upgrade_costs.csv',
                petUpgradeCosts: 'pet_upgrade_costs.csv',
                relicUpgradeCosts: 'relic_upgrade_costs.csv',
                characterUpgradeCosts: 'character_upgrade_costs.csv'
            };
            const loadedGameData = {};
            const missingFiles = [];
            // 嘗試載入所有 CSV，若失敗則使用模擬數據並記錄檔名
            for (const key in dataFiles) {
                try {
                    loadedGameData[key] = await fetchAndParseCsv(dataFiles[key]);
                } catch (error) {
                    console.warn(`無法載入 ${dataFiles[key]}，將使用模擬數據。`, error);
                    loadedGameData[key] = MOCK_GAME_DATA[key];
                    missingFiles.push(dataFiles[key]);
                }
            }
            // 進入主程式邏輯
            main(loadedGameData, containers, missingFiles);
        });

        /**
         * @description 主應用程式邏輯，在數據載入後執行。
         * @param {Object} GAME_DATA - 載入或模擬的遊戲數據。
         * @param {Object} containers - 頁面上的 DOM 元素容器。
         * @param {Array<string>} missingFiles - 載入失敗的 CSV 檔名列表。
         */
        function main(GAME_DATA, containers, missingFiles) {
            preprocessCostData(GAME_DATA);
            
            /**
             * @description 根據設定檔，動態生成整個計算機的 HTML 介面。
             */
            function render() {
                // (渲染邏輯與前一版相同)
                let levelHtml = '', ownedHtml = '', prodInputHtml = '', bonusHtml = '', targetHtml = '', relicDistHtml = '';
                // === 角色等級與幻獸等級區塊 ===
                const charCat = categories.find(c => c.id === 'character');
                if (charCat) {
                // 角色等級：單行獨立
                levelHtml += `
                    <div class="mb-6">
                    <h3 class="text-lg font-semibold text-[#2cb5ab] mb-3">角色等級</h3>
                    <div class="grid grid-cols-1 gap-4 mb-6 border-b border-[#e5eff1] pb-6">
                        <div>
                        <label class="block text-sm font-bold mb-2">${charCat.name}</label>
                        <input type="number" id="${charCat.id}-current" placeholder="目前" class="input-field rounded w-full p-2">
                        </div>
                    </div>
                    </div>
                `;
                }

                // 幻獸等級：橫向四格一行
                const petCats = categories.filter(c => c.id.startsWith('pet'));
                if (petCats.length > 0) {
                levelHtml += `
                    <div class="mb-6">
                    <h3 class="text-lg font-semibold text-[#2cb5ab] mb-3">幻獸等級</h3>
                    <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 border-b border-[#e5eff1] pb-6">
                        ${petCats
                        .map(cat => `
                            <div>
                            <label class="block text-sm font-bold mb-2">${cat.name}</label>
                            <input type="number" id="${cat.id}-current" placeholder="目前" class="input-field rounded w-full p-2">
                            </div>
                        `)
                        .join('')}
                    </div>
                    </div>
                `;
                }
                // === 裝備等級與技能等級區塊 ===
                levelHtml += `<h3 class="text-lg font-semibold text-[#2cb5ab] pb-2 mb-3">裝備等級</h3>`;
                levelHtml += `<div class="grid grid-cols-2 gap-x-6 mb-4 border-b border-gray-700 pb-6">`;
                levelHtml += `<div>`;
                const equipCol1Cats = categories.filter(c => ['equipment_main_weapon', 'equipment_off_weapon'].includes(c.id));
                equipCol1Cats.forEach(cat => { levelHtml += `<div class="mb-4"><label class="block text-sm font-bold mb-2">${cat.name}</label><input type="number" id="${cat.id}-current" placeholder="目前" class="input-field rounded w-full p-2"></div>`; });
                levelHtml += `</div><div>`;
                const equipCol2Cats = categories.filter(c => ['equipment_helmet', 'equipment_armor', 'equipment_boots'].includes(c.id));
                equipCol2Cats.forEach(cat => { levelHtml += `<div class="mb-4"><label class="block  text-sm font-bold mb-2">${cat.name}</label><input type="number" id="${cat.id}-current" placeholder="目前" class="input-field rounded w-full p-2"></div>`; });
                levelHtml += `</div></div>`;
                levelHtml += `<h3 class="text-lg font-semibold text-[#2cb5ab] pb-2 mb-3">技能等級</h3>`;
                levelHtml += `<div class="grid grid-cols-2 gap-x-6 mb-4 border-b border-gray-700 pb-6">`;
                levelHtml += `<div>`;
                const skillCombatCats = categories.filter(c => c.id.startsWith('skill_combat'));
                skillCombatCats.forEach(cat => { levelHtml += `<div class="mb-4"><label class="block text-sm font-bold mb-2">${cat.name}</label><input type="number" id="${cat.id}-current" placeholder="目前" class="input-field rounded w-full p-2"></div>`; });
                levelHtml += `</div><div>`;
                const skillArcaneCats = categories.filter(c => c.id.startsWith('skill_arcane'));
                skillArcaneCats.forEach(cat => { levelHtml += `<div class="mb-4"><label class="block text-sm font-bold mb-2">${cat.name}</label><input type="number" id="${cat.id}-current" placeholder="目前" class="input-field rounded w-full p-2"></div>`; });
                levelHtml += `</div></div>`;
                
                targetLevelConfig.forEach(t => { 
                    targetHtml += `<div><label for="target-${t.id}" class="block text-sm font-bold mb-2">${t.name}</label><input type="number" id="target-${t.id}" placeholder="目標" class="input-field rounded w-full p-2">`;
                    if (t.id === 'character') {
                        targetHtml += `<div id="target-char-reachable-level" class="text-xs text-gray-400 mt-1">最低可達: --</div>`;
                    }
                    targetHtml += `</div>`;
                });

                for (let i = 10; i <= 20; i++) { relicDistHtml += `<div><label for="relic-level-${i}" class="block text-sm font-bold mb-2">等級 ${i}</label><input type="number" id="relic-level-${i}" placeholder="數量" class="input-field relic-dist-input rounded w-full p-2"></div>`; }
                for (const matId in materials) { ownedHtml += `<div class="flex items-center"><label for="owned-${matId}" class="w-full block text-sm font-bold">${materials[matId].icon} ${materials[matId].name}</label><input type="number" id="owned-${matId}" placeholder="0" class="input-field rounded w-full p-2"></div>`; }
                for (const srcId in productionSources) {
                    const mat = materials[productionSources[srcId].materialId];
                    prodInputHtml += `<div><label class="block text-sm font-bold mb-2">${mat.icon} ${mat.name}</label><div class="grid grid-cols-2 gap-2"><div><label class="text-xs text-gray-400">生產等級</label><div class="grid grid-cols-2 gap-1"><input type="number" id="prod-level-current-${srcId}" placeholder="目前" class="input-field production-related-input rounded w-full p-2 text-sm"><input type="number" id="prod-level-target-${srcId}" placeholder="目標" class="input-field production-related-input rounded w-full p-2 text-sm"></div></div><div><label class="text-xs text-gray-400">時產量 (理論/手動)</label><div class="grid grid-cols-2 gap-1"><input type="number" id="theoretical-hourly-${srcId}" placeholder="理論" class="input-field rounded w-full p-2 text-sm" disabled><input type="number" id="manual-hourly-${srcId}" placeholder="手動" class="input-field rounded w-full p-2 text-sm"></div></div></div></div>`;
                }
                for (const bonusId in globalBonuses) { bonusHtml += `<div><label for="bonus-${bonusId}" class="block text-sm font-bold mb-1">${globalBonuses[bonusId].name}</label><input type="number" id="bonus-${bonusId}" placeholder="0" class="input-field production-related-input rounded w-full p-2"></div>`; }
                
                containers.levelInputs.innerHTML = levelHtml;
                containers.ownedMaterials.innerHTML = ownedHtml;
                containers.productionInputs.innerHTML = prodInputHtml;
                containers.globalBonuses.innerHTML = bonusHtml;
                containers.targetLevels.innerHTML = targetHtml;
                containers.relicDistributionInputs.innerHTML = relicDistHtml;
            }

            /**
             * @description 更新「現在時間」的顯示。
             */
            function updateCurrentTime() {
                if (containers.currentTimeDisplay) {
                    const now = new Date();
                    const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
                    containers.currentTimeDisplay.textContent = now.toLocaleString('sv-SE', options);
                }
            }

            /**
             * @description 更新遺物分佈區塊的總數顯示。
             */
            function updateRelicTotal() {
                let total = 0;
                document.querySelectorAll('.relic-dist-input').forEach(el => { total += parseInt(el.value) || 0; });
                const display = document.getElementById('relic-total-display');
                display.textContent = `(${total}/20)`;
                if (total !== 20 && total > 0) { display.classList.add('text-red-400'); display.classList.remove('text-gray-400'); } 
                else { display.classList.remove('text-red-400'); display.classList.add('text-gray-400'); }
            }

            /**
             * @description 當生產等級或全域加成變動時，重新計算理論時產量。
             */
            function updateTheoreticalProduction() {
                // TODO: [計算] 此處為全域加成的計算公式
                const totalBonus = 1 +
                    (parseFloat(document.getElementById('bonus-map').value) || 0) / 100 +
                    (parseFloat(document.getElementById('bonus-relic').value) || 0) / 100 +
                    (parseFloat(document.getElementById('bonus-pass').value) || 0) / 100;
                for (const srcId in productionSources) {
                    const level = parseInt(document.getElementById(`prod-level-current-${srcId}`).value) || 0;
                    const baseProd = level > 0 ? productionSources[srcId].baseProd(level) : 0;
                    document.getElementById(`theoretical-hourly-${srcId}`).value = Math.floor(baseProd * totalBonus);
                }
            }

            /**
             * @description 主計算函式，會被所有輸入框的 'input' 事件觸發。
             */
            function calculate() {
                let required = {}, prodUpgradeCost = {}, hasError = false, hasInput = false;
                const missingDataErrors = []; 

                // --- 讀取所有目標等級 ---
                const targets = {};
                targetLevelConfig.forEach(t => { targets[t.id] = parseInt(document.getElementById(`target-${t.id}`).value) || 0; });
                
                // --- 計算並更新「最低可達等級」 ---
                const reachableCharLevelDisplay = document.getElementById('target-char-reachable-level');
                const currentCharacterLevel = parseInt(document.getElementById('character-current').value) || 0;
                const ownedExp = parseInt(document.getElementById('owned-exp').value) || 0;
                const bedExpHourly = parseFloat(document.getElementById('bed-exp-hourly').value) || 0;
                const targetTimeStr = document.getElementById('target-time').value;
                let reachableCharLevel = currentCharacterLevel;
                
                // TODO: [計算] 最低可達角色等級的計算邏輯
                if (targetTimeStr && cumulativeCostData['character']) {
                    const hours = Math.max(0, (new Date(targetTimeStr).getTime() - new Date().getTime()) / 36e5);
                    const currentInvestedExp = getCumulativeCost(cumulativeCostData['character'], currentCharacterLevel).exp;
                    const totalExpPool = currentInvestedExp + ownedExp + (bedExpHourly * hours);
                    const foundIndex = cumulativeCostData['character'].findLastIndex(d => d.exp <= totalExpPool);
                    reachableCharLevel = (foundIndex !== -1) ? cumulativeCostData['character'][foundIndex].level : currentCharacterLevel;
                }
                
                // 更新介面顯示
                reachableCharLevelDisplay.textContent = `最低可達: ${reachableCharLevel > 0 ? reachableCharLevel : '--'}`;

                // --- 遺物成本計算 ---
                // TODO: [計算] 遺物升級所需成本的核心計算邏輯
                const targetRelicResonance = targets.relic_resonance;
                let relicCount = 0;
                for (let i = 10; i <= 20; i++) {
                    const count = parseInt(document.getElementById(`relic-level-${i}`).value) || 0;
                    if (count > 0) hasInput = true;
                    relicCount += count;
                    for (let j = 0; j < count; j++) {
                        const current = i;
                        const finalTarget = Math.max(current, targetRelicResonance);
                        if (finalTarget > current) {
                            const costTable = cumulativeCostData.relic;
                            const sourceDataTable = GAME_DATA.relicUpgradeCosts;
                            let missingLevelFound = false;
                            for (let lvl = current + 1; lvl <= finalTarget; lvl++) {
                                if (!sourceDataTable.find(d => d.level === lvl)) {
                                    missingDataErrors.push(`遺物缺少 ${lvl} 級的升級數據`);
                                    missingLevelFound = true;
                                    break;
                                }
                            }
                            if (!missingLevelFound && costTable) {
                                const startCost = getCumulativeCost(costTable, current);
                                const endCost = getCumulativeCost(costTable, finalTarget);
                                Object.keys(endCost).forEach(key => {
                                    if (key.startsWith('cost_')) {
                                        const matId = getMaterialIdFromCostKey(key);
                                        const startValue = startCost[key] || 0;
                                        required[matId] = (required[matId] || 0) + (endCost[key] - startValue);
                                    }
                                });
                            }
                        }
                    }
                }
                if (relicCount > 0 && relicCount !== 20) { hasError = true; }

                // --- 其他項目成本計算 ---
                // TODO: [計算] 角色、裝備、技能、幻獸升級所需成本的核心計算邏輯
                categories.forEach(cat => {
                    const current = parseInt(document.getElementById(`${cat.id}-current`).value) || 0;
                    if (current > 0) hasInput = true;
                    let targetResonance = 0;
                    if (cat.id === 'character') { targetResonance = targets.character; } 
                    else if (cat.id.startsWith('equipment_')) { targetResonance = targets.equipment_resonance; } 
                    else if (cat.id.startsWith('skill_')) { targetResonance = targets.skill_resonance; } 
                    else if (cat.id.startsWith('pet')) { targetResonance = targets.pet_resonance; } 
                    
                    const finalTarget = Math.max(current, targetResonance);
                    if (finalTarget > 0 && !hasInput) hasInput = true;
                    if (finalTarget > current) {
                        let costTable, sourceDataTable, itemName;
                        if (cat.id.startsWith('equipment_')) {
                            costTable = cumulativeCostData.equipment;
                            sourceDataTable = GAME_DATA.equipmentUpgradeCosts;
                            itemName = '裝備';
                        } else if (cat.id.startsWith('skill_')) {
                            costTable = cumulativeCostData.skill;
                            sourceDataTable = GAME_DATA.skillUpgradeCosts;
                            itemName = '技能';
                        } else if (cat.id.startsWith('pet')) {
                            costTable = cumulativeCostData.pet;
                            sourceDataTable = GAME_DATA.petUpgradeCosts;
                            itemName = '幻獸';
                        } else { // 角色
                            costTable = cumulativeCostData[cat.id];
                            sourceDataTable = GAME_DATA.characterUpgradeCosts;
                            itemName = '角色';
                        }
                        let missingLevelFound = false;
                        if (sourceDataTable) {
                            for (let lvl = current + 1; lvl <= finalTarget; lvl++) {
                                if (!sourceDataTable.find(d => d.level === lvl)) {
                                    missingDataErrors.push(`${itemName}缺少 ${lvl} 級的升級數據`);
                                    missingLevelFound = true;
                                    break;
                                }
                            }
                        }
                        if (!missingLevelFound && costTable) {
                            const startCost = getCumulativeCost(costTable, current);
                            const endCost = getCumulativeCost(costTable, finalTarget);
                            Object.keys(endCost).forEach(key => {
                                const startValue = startCost[key] || 0;
                                if (key.startsWith('cost_')) {
                                    const matId = getMaterialIdFromCostKey(key);
                                    required[matId] = (required[matId] || 0) + (endCost[key] - startValue);
                                } else if (materials[key]) {
                                    required[key] = (required[key] || 0) + (endCost[key] - startValue);
                                }
                            });
                        }
                    }
                });

                // --- 生產建築升級成本計算 ---
                // TODO: [計算] 推車生產建築升級所需成本的核心計算邏輯
                for (const srcId in productionSources) {
                    const current = parseInt(document.getElementById(`prod-level-current-${srcId}`).value) || 0;
                    const target = parseInt(document.getElementById(`prod-level-target-${srcId}`).value) || 0;
                    if (target > current) {
                        const sourceDataTable = GAME_DATA.productionUpgradeCosts;
                        let missingLevelFound = false;
                        for (let lvl = current + 1; lvl <= target; lvl++) {
                            if (!sourceDataTable.find(d => d.level === lvl)) {
                                missingDataErrors.push(`推車(${materials[productionSources[srcId].materialId].name})缺少 ${lvl} 級的升級數據`);
                                missingLevelFound = true;
                                break;
                            }
                        }
                        if (!missingLevelFound) {
                            const costTable = cumulativeCostData.production;
                            const startCost = getCumulativeCost(costTable, current);
                            const endCost = getCumulativeCost(costTable, target);
                            Object.keys(endCost).forEach(key => {
                                if (key.startsWith('cost_')) {
                                    const matId = getMaterialIdFromCostKey(key);
                                    const startValue = startCost[key] || 0;
                                    prodUpgradeCost[matId] = (prodUpgradeCost[matId] || 0) + (endCost[key] - startValue);
                                }
                            });
                        }
                    }
                }
                const uniqueMissingDataErrors = [...new Set(missingDataErrors)];
                if (hasError || uniqueMissingDataErrors.length > 0) {
                    let errorHtml = '';
                    if (hasError) { errorHtml += '<p class="text-red-400 text-center py-4">輸入有誤 (例如遺物總數不為20)，請檢查。</p>'; }
                    if (uniqueMissingDataErrors.length > 0) {
                        errorHtml += `<div class="bg-red-900/50 border-l-4 border-red-400 text-red-300 p-3 rounded-lg mb-4 text-sm"><h4 class="font-bold">數據缺失</h4><p>CSV檔案中缺少以下等級的數據，計算無法完成：<br>${uniqueMissingDataErrors.join('<br>')}</div>`;
                    }
                    containers.results.innerHTML = errorHtml;
                    return;
                }
                if (!hasInput) { renderResults({}, {}, {}, {}); return; }
                
                // TODO: [計算] 掛機收益計算邏輯
                let gainsFromTime = {};
                if (targetTimeStr) {
                    const hours = Math.max(0, (new Date(targetTimeStr).getTime() - new Date().getTime()) / 36e5);
                    for (const srcId in productionSources) {
                        const manual = parseFloat(document.getElementById(`manual-hourly-${srcId}`).value) || 0;
                        const theoretical = parseFloat(document.getElementById(`theoretical-hourly-${srcId}`).value) || 0;
                        const hourlyGain = manual > 0 ? manual : theoretical;
                        gainsFromTime[productionSources[srcId].materialId] = (gainsFromTime[productionSources[srcId].materialId] || 0) + Math.floor(hourlyGain * hours);
                    }
                    if (bedExpHourly > 0) { gainsFromTime['exp'] = (gainsFromTime['exp'] || 0) + Math.floor(bedExpHourly * hours); }
                }

                // TODO: [計算] 最終資源缺口計算邏輯
                let deficit = {};
                for (const matId in materials) {
                    const totalRequired = (required[matId] || 0) + (prodUpgradeCost[matId] || 0);
                    const owned = parseInt(document.getElementById(`owned-${matId}`).value) || 0;
                    const gained = gainsFromTime[matId] || 0;
                    deficit[matId] = Math.max(0, totalRequired - owned - gained);
                }
                
                updateLevelUpTimeAndNotification(currentCharacterLevel, ownedExp, bedExpHourly);
                renderResults(required, prodUpgradeCost, gainsFromTime, deficit);
            }

            /**
             * @description 計算並更新下次升級所需時間及設定通知。
             */
            function updateLevelUpTimeAndNotification(currentLevel, ownedExp, bedExpHourly) {
                const levelUpTimeDisplay = document.getElementById('bed-levelup-time');
                if (notificationTimerId) { clearTimeout(notificationTimerId); notificationTimerId = null; }
                if (bedExpHourly <= 0 || currentLevel >= MAX_LEVEL) { levelUpTimeDisplay.textContent = '預計升級時間: --'; return; }
                
                // TODO: [計算] 角色下次升級時間的計算邏輯
                const currentTotalExp = getCumulativeCost(cumulativeCostData['character'], currentLevel).exp;
                const nextLevelData = cumulativeCostData['character'].find(d => d.level === currentLevel + 1);
                if (!nextLevelData) { levelUpTimeDisplay.textContent = '已達最高等級'; return; }
                const expForNextLevel = nextLevelData.exp;
                const expNeeded = expForNextLevel - (currentTotalExp + ownedExp);
                if (expNeeded <= 0) { levelUpTimeDisplay.textContent = '預計升級時間: 可立即升級'; return; }
                const hoursNeeded = expNeeded / bedExpHourly;
                const levelUpTimestamp = new Date().getTime() + hoursNeeded * 3600 * 1000;
                const levelUpDate = new Date(levelUpTimestamp);
                const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' };
                levelUpTimeDisplay.textContent = `預計升級時間: ${levelUpDate.toLocaleString('sv-SE', options)}`;
                
                // 設定推播通知
                if ('Notification' in window && Notification.permission === 'granted') {
                    const notificationTime = levelUpTimestamp - 5 * 60 * 1000; // 提前 5 分鐘
                    const delay = notificationTime - new Date().getTime();
                    if (delay > 0) {
                        notificationTimerId = setTimeout(() => {
                            new Notification('杖劍傳說提醒', {
                                body: `您的角色即將在約 5 分鐘後升級至 ${currentLevel + 1} 級！`,
                                icon: 'https://placehold.co/192x192/4299e1/white?text=LV'
                            });
                        }, delay);
                    }
                }
            }

            /**
             * @description 將計算結果渲染到右側的「計算總覽」區塊。
             */
            function renderResults(req, prodCost, gains, deficit) {
                let html = '';
                if (missingFiles.length > 0) { html += `<div class="bg-yellow-900/50 border-l-4 border-yellow-400 text-yellow-300 p-3 rounded-lg mb-4 text-sm"><h4 class="font-bold">注意</h4><p>無法載入以下數據檔案，目前正使用模擬數據：<br>${missingFiles.join(', ')}</p></div>`; }
                const formatNum = (n) => n.toLocaleString();
                let costHtml = '';
                for (const matId in req) { if (req[matId] > 0) { costHtml += `<div class="flex justify-between items-center text-sm"><span>${materials[matId].icon} ${materials[matId].name}</span><strong>${formatNum(req[matId])}</strong></div>`; } }
                if (costHtml) { html += `<div class="cost-item p-3 rounded-lg space-y-1"><h4 class="font-bold text-orange-300">角色養成所需</h4>${costHtml}</div>`; }
                let prodCostHtml = '';
                for (const matId in prodCost) { if (prodCost[matId] > 0) { prodCostHtml += `<div class="flex justify-between items-center text-sm"><span>${materials[matId].icon} ${materials[matId].name}</span><strong>${formatNum(prodCost[matId])}</strong></div>`; } }
                if (prodCostHtml) { html += `<div class="cost-item p-3 rounded-lg space-y-1"><h4 class="font-bold text-orange-300">生產等級升級所需</h4>${prodCostHtml}</div>`; }
                let gainsHtml = '';
                for (const matId in gains) { if (gains[matId] > 0) { gainsHtml += `<div class="flex justify-between items-center text-sm"><span>${materials[matId].icon} ${materials[matId].name}</span><strong class="text-blue-300">+${formatNum(gains[matId])}</strong></div>`; } }
                if (gainsHtml) { html += `<div class="info-item p-3 rounded-lg space-y-1"><h4 class="font-bold text-blue-300">預計掛機獲得</h4>${gainsHtml}</div>`; }
                let deficitHtml = '';
                for (const matId in deficit) {
                    if (deficit[matId] > 0) {
                        deficitHtml += `<div class="result-item p-4 rounded-lg flex justify-between items-center"><div class="flex items-center"><span class="text-2xl mr-3">${materials[matId].icon}</span><span class="font-bold text-lg">${materials[matId].name}</span></div><strong class="text-xl font-semibold text-red-400">-${formatNum(deficit[matId])}</strong></div>`;
                    }
                }
                if (deficitHtml) { html += `<h3 class="text-xl font-bold text-red-400 border-t border-gray-600 pt-4 mt-4">最終資源缺口</h3>` + deficitHtml; } 
                else if (costHtml || prodCostHtml) { html += '<p class="text-green-400 text-center py-6 font-bold text-lg">恭喜！根據計算，你的資源已完全足夠！</p>'; }
                containers.results.innerHTML = html || '<p class="text-gray-400 text-center py-8">請輸入資料以自動計算。</p>';
            }

            /**
             * @description 綁定所有輸入框的事件監聽器以觸發自動計算。
             */
            function setupEventListeners() {
                document.body.addEventListener('input', (event) => {
                    const target = event.target;
                    if (target.matches('input[type=number], input[type=datetime-local]')) {
                        if (target.classList.contains('production-related-input')) { updateTheoreticalProduction(); }
                        if (target.classList.contains('relic-dist-input')) { updateRelicTotal(); }
                        calculate();
                    }
                });

                const notificationBtn = document.getElementById('enable-notifications-btn');
                if ('Notification' in window) {
                    notificationBtn.addEventListener('click', () => {
                        Notification.requestPermission().then(permission => {
                            if (permission === 'granted') {
                                notificationBtn.textContent = '通知已啟用';
                                notificationBtn.disabled = true;
                                new Notification('通知已啟用', { body: '將在角色升級前 5 分鐘提醒您！' });
                            } else {
                                notificationBtn.textContent = '通知被拒絕';
                                notificationBtn.disabled = true;
                            }
                        });
                    });
                } else {
                    notificationBtn.textContent = '瀏覽器不支援通知';
                    notificationBtn.disabled = true;
                }
            }

            render();
            setupEventListeners();
            updateTheoreticalProduction();
            updateRelicTotal();
            setInterval(updateCurrentTime, 1000);
            updateCurrentTime();
            calculate(); // 初始計算一次
        }
    </script>
</body>
</html>

