<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>杖劍傳說 素材計算機</title>
    <!-- tailwindcss CDN only for local / testing use -->
    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
    body {
        font-family: 'Noto Sans TC', sans-serif;
        background: linear-gradient(180deg, #f5fafb 0%, #e6f3f4 100%);
        color: #1e293b; /* 深藍灰文字 */
    }

    .card {
        background: #ffffffd9; /* 半透明白卡片 */
        border: 1px solid #cde5e8;
        box-shadow: 0 2px 8px rgba(38,115,119,.15);
        border-radius: 10px;
        transition: all .25s ease;
    }

    .input-field {
        background-color: #f7fbfc;
        color: #1e293b;
        border: 1px solid #b6d7da;
        transition: border-color .25s, box-shadow .25s, background-color .25s;
    }

    .input-field:focus {
        border-color: #2cb5ab;
        box-shadow: 0 0 6px rgba(44,181,171,.4);
        outline: none;
        background-color: #f0fafa;
    }

    .input-field:disabled {
        background-color: #eef3f4;
        color: #94a3b8;
        border-color: #cbd5e1;
        cursor: not-allowed;
    }

    .btn-primary {
        background: linear-gradient(135deg, #31c9be 0%, #1a9e95 100%);
        color: #fffef8;
        border: 1px solid #21b8ac;
        box-shadow: 0 2px 6px rgba(34,180,168,.25);
        transition: background .3s, transform .15s;
    }

    .btn-primary:hover {
        background: linear-gradient(135deg, #45dfd3 0%, #23b7ac 100%);
        transform: translateY(-2px);
    }

    .result-item { background:#fffdf5; border-left:4px solid #f48b45; box-shadow: inset 0 0 8px rgba(244,139,69,.2); }
    .info-item   { background:#f0faf9; border-left:4px solid #2cb5ab; box-shadow: inset 0 0 8px rgba(44,181,171,.15); }
    .cost-item   { background:#fffbee; border-left:4px solid #facc15; box-shadow: inset 0 0 8px rgba(249,209,98,.2); }

    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button { opacity:.4; }

    /* 捲軸 */
    .custom-scrollbar::-webkit-scrollbar { width:8px; height:8px; }
    .custom-scrollbar::-webkit-scrollbar-track { background:#f2f8f9; }
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg,#b3dede 0%,#89cfcf 100%); border-radius:4px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg,#6dcacb 0%,#4fbebf 100%);
    }

    /* 標題顏色 */
    h1,h2,h3,h4 { color:#165f63; text-shadow:0 1px 2px rgba(22,95,99,.15); }
    .text-accent{ color:#1fb7ad; }
    .text-gold  { color:#d4a418; }
    .text-warning{ color:#d65a2d; }
  </style>
</head>

<body class="p-4 lg:p-6">
  <div class="w-full max-w-7xl mx-auto">
    <!-- ===== 頁首 ===== -->
    <header class="text-center mb-6">
      <h1 class="text-3xl md:text-4xl font-bold">杖劍傳說 素材計算機</h1>
    </header>

    <!-- ===== 目標時間 / 現在時間 ===== -->
    <div class="card rounded-lg p-4 shadow-lg mb-6 max-w-lg mx-auto">
      <div class="flex items-center justify-center gap-x-6">
        <div>
          <h3 class="text-lg font-semibold text-center mb-2">目標時間</h3>
          <input type="datetime-local" id="target-time" class="input-field rounded w-full py-2 px-3">
        </div>
        <div>
          <h3 class="text-lg font-semibold text-center mb-2">現在時間</h3>
          <!-- 使用深底白字以區分 -->
          <div id="current-time-display" class="text-center bg-gray-900/50 p-2 rounded h-[42px] flex items-center justify-center min-w-[210px] text-[#e2e8f0]"></div>
        </div>
      </div>
    </div>
    <!-- 賽季選項 -->
    <div class="text-center mb-6">
      <label for="season-select" class="mr-2 font-semibold">賽季選項:</label>
      <select id="season-select" class="input-field rounded p-2">
        <option value="s1">S1 澤之國</option>
        <!-- <option value="s2">S2 龍之國</option> -->
        <!-- 未來可擴充其他賽季 -->
      </select>
    </div>
    <!-- ===== 目標等級（共鳴） ===== -->
    <div class="card rounded-lg p-6 shadow-lg mb-6 max-w-6xl mx-auto">
      <h3 class="text-xl font-bold text-center mb-4">目標等級 (共鳴)</h3>
      <!-- 固定六欄，確保對齊 -->
      <div id="target-levels" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-4"></div>
    </div>

    <!-- ===== 遺物分佈 ===== -->
    <div class="card rounded-lg p-6 shadow-lg mb-6 max-w-6xl mx-auto">
      <h3 class="text-xl font-bold text-center mb-4">遺物等級分佈 <span id="relic-total-display" class="text-sm font-normal text-gray-400">(0/20)</span></h3>
      <div id="relic-distribution-inputs" class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-11 gap-x-6 gap-y-4"></div>
    </div>

    <!-- ===== 三欄主內容 ===== -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- 左：角色目前等級 -->
      <div class="card rounded-xl p-0 shadow-lg max-h-[75vh] flex flex-col">
        <h2 class="text-2xl font-bold border-b pb-3 sticky top-0 z-10 px-6 py-3 m-0 bg-white/90 backdrop-blur border-[#cde5e8]">角色目前等級</h2>
        <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
          <div id="level-inputs" class="pt-2"></div>
        </div>
      </div>

      <!-- 中：小推車（目前僅手動時產） -->
      <div class="card rounded-xl p-0 shadow-lg max-h-[75vh] flex flex-col">
        <h2 class="text-2xl font-bold border-b pb-3 sticky top-0 z-10 px-6 py-3 m-0 bg-white/90 backdrop-blur border-[#cde5e8]">小推車</h2>
        <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
          <div id="production-inputs" class="space-y-6 mb-6"></div>
        </div>
      </div>

      <!-- 右：素材資訊 + 計算總覽 -->
      <div class="flex flex-col gap-6">
        <div class="card rounded-xl p-0 shadow-lg max-h-[40vh] flex flex-col">
          <h2 class="text-2xl font-bold border-b pb-3 sticky top-0 z-10 px-6 py-3 m-0 bg-white/90 backdrop-blur border-[#cde5e8]">素材資訊</h2>
          <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
            <div class="pt-2 mb-6 border-b border-[#e5eff1] pb-6">
              <h3 class="text-lg font-semibold text-accent mb-3">床</h3>
              <div class="flex items-center">
                <label for="bed-exp-hourly" class="w-full block text-sm font-bold">📖 每小時經驗產量</label>
                <input type="number" id="bed-exp-hourly" placeholder="0" class="input-field rounded w-full p-2">
              </div>
              <div id="bed-levelup-time" class="text-xs text-gray-500 mt-2">預計升級時間: --</div>
            </div>

            <h3 class="text-lg font-semibold text-accent mb-3">目前持有素材</h3>
            <div id="owned-materials" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-1 gap-4"></div>
          </div>
        </div>

        <div class="card rounded-xl p-0 shadow-lg max-h-[43.5vh] flex flex-col">
          <h2 class="text-2xl font-bold border-b pb-3 sticky top-0 z-10 px-6 py-3 m-0 bg-white/90 backdrop-blur border-[#cde5e8]">計算總覽</h2>
          <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
            <div id="results" class="space-y-4 pt-2">
              <p class="text-gray-500 text-center py-8">正在載入遊戲數據...</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ===== 底部：功能按鈕 ===== -->
    <footer class="text-center text-gray-500 mt-10 text-sm">
        <div class="space-x-4">
            <button id="enable-notifications-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg text-xs">啟用升級通知</button>
            <button id="clear-data-btn" class="bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg text-xs">清除本地紀錄</button>
        </div>
        <p class="mt-4">重要：請將所有 .csv 檔案與此 HTML 檔案放在同一個資料夾，並透過本地伺服器 (Local Server) 瀏覽。</p>
    </footer>
  </div>

  <script>
    /* ---------------------------------------
     * 基礎設定與資料模型
     * ------------------------------------- */
    const MAX_LEVEL = 200;              // 角色最高等級上限
    let notificationTimerId = null;     // 推播計時器（避免重複排程）

    // 左欄：可輸入的目前等級
    const categories = [
      { id:'character', name:'角色等級' },
      { id:'equipment_main_weapon', name:'主武器', group:'裝備等級' },
      { id:'equipment_off_weapon',  name:'副武器', group:'裝備等級' },
      { id:'equipment_helmet',      name:'頭盔',   group:'裝備等級' },
      { id:'equipment_armor',       name:'鎧甲',   group:'裝備等級' },
      { id:'equipment_boots',       name:'戰靴',   group:'裝備等級' },
      { id:'skill_combat1',         name:'戰技一', group:'技能等級' },
      { id:'skill_combat2',         name:'戰技二', group:'技能等級' },
      { id:'skill_combat3',         name:'戰技三', group:'技能等級' },
      { id:'skill_combat4',         name:'戰技四', group:'技能等級' },
      { id:'skill_arcane1',         name:'祕法一', group:'技能等級' },
      { id:'skill_arcane2',         name:'祕法二', group:'技能等級' },
      { id:'skill_arcane3',         name:'祕法三', group:'技能等級' },
      { id:'skill_arcane4',         name:'祕法四', group:'技能等級' },
      { id:'pet1', name:'幻獸一', group:'幻獸等級' },
      { id:'pet2', name:'幻獸二', group:'幻獸等級' },
      { id:'pet3', name:'幻獸三', group:'幻獸等級' },
      { id:'pet4', name:'幻獸四', group:'幻獸等級' },
    ];

    // 頂部：目標等級（共鳴）欄位
    const targetLevelConfig = [
      { id:'character',         name:'角色等級' },
      { id:'equipment_resonance', name:'裝備共鳴' },
      { id:'skill_resonance',     name:'技能共鳴' },
      { id:'pet_resonance',       name:'幻獸共鳴' },
      { id:'relic_resonance',     name:'遺物共鳴' },
      { id:'primordial_star',     name:'原初之星', readonly:true }, // 唯讀，自動計算
    ];

    // 可用素材（右欄）
    const materials = {
      exp:{ name:'角色經驗', icon:'📖' },
      rola:{ name:'羅拉幣', icon:'💰' },
      essence:{ name:'歷戰精華', icon:'✨' },
      sand:{ name:'時之砂', icon:'⏳' },
      stoneOre:{ name:'粗煉石', icon:'💎' },
      refiningStone:{ name:'精煉石', icon:'🔨' },
      freezeDried:{ name:'幻獸凍乾', icon:'🍖' },
    };

    // 推車（只用於掛機收益，先保留識別）
    const productionSources = {
      rola:        { materialId:'rola' },
      essence:     { materialId:'essence' },
      stoneOre:    { materialId:'stoneOre' },
      sand:        { materialId:'sand' },
      freezeDried: { materialId:'freezeDried' }
    };

    // 預處理後的「累積成本表」存放處
    const cumulativeCostData = {};

    // 讀檔失敗時的備用模擬資料
    const MOCK_GAME_DATA = {
      equipmentUpgradeCosts: [
        { level:1,  cost_stone_ore:10,  cost_rola:100,  cost_refining_stone:0 },
        { level:2,  cost_stone_ore:20,  cost_rola:200,  cost_refining_stone:0 },
        { level:30, cost_stone_ore:500, cost_rola:5000, cost_refining_stone:1 },
      ],
      skillUpgradeCosts: [
        { level:1, cost_essence:50 },
        { level:2, cost_essence:75 },
        { level:3, cost_essence:100 },
      ],
      petUpgradeCosts: [
        { level:1, cost_freeze_dried:30 },
        { level:2, cost_freeze_dried:45 },
        { level:3, cost_freeze_dried:60 },
      ],
      relicUpgradeCosts: [
        { level:1, cost_sand:100, cost_rola:1000 },
        { level:2, cost_sand:150, cost_rola:1500 },
        { level:3, cost_sand:200, cost_rola:2000 },
      ],
      // 角色升級的「到達該等級所需累積經驗」
      characterUpgradeCosts: Array.from({ length: MAX_LEVEL }, (_, i) => ({
        level: i + 1, cost_exp: Math.floor(200 * Math.pow(i + 1, 2.2))
      })),
    };
    
    // 定義不同賽季的 CSV 檔案路徑
    const DATA_FILES_CONFIG = {
        s1: {
            equipmentUpgradeCosts: 'equipment_upgrade_costs_s1.csv',
            skillUpgradeCosts: 'skill_upgrade_costs_s1.csv',
            petUpgradeCosts: 'pet_upgrade_costs_s1.csv',
            relicUpgradeCosts: 'relic_upgrade_costs_s1.csv',
            characterUpgradeCosts: 'character_upgrade_costs_s1.csv',
        },
        s2: {
            equipmentUpgradeCosts: 'equipment_upgrade_costs_s2.csv',
            skillUpgradeCosts: 'skill_upgrade_costs_s2.csv',
            petUpgradeCosts: 'pet_upgrade_costs_s2.csv', 
            relicUpgradeCosts: 'relic_upgrade_costs_s2.csv',
            characterUpgradeCosts: 'character_upgrade_costs_s2.csv',
        }
    };


    // 讀取 CSV（簡易解析：第一列為標頭）
    async function fetchAndParseCsv(url){
      const res = await fetch(url);
      if(!res.ok) throw new Error(`無法載入 CSV: ${url}`);
      const text = await res.text();
      const lines = text.trim().split('\n');
      const headers = lines[0].split(',').map(h=>h.trim());
      return lines.slice(1).map(line=>{
        const values = line.split(',').map(v=>v.trim());
        const obj = {};
        headers.forEach((h,i)=>{
          const num = parseFloat(values[i]);
          obj[h] = isNaN(num) ? 0 : num;
        });
        return obj;
      });
    }

    // 將成本資料轉成「累積總和表」
    function preprocessCostData(GAME_DATA){
      const dataSources = {
        equipment:  GAME_DATA.equipmentUpgradeCosts,
        skill:      GAME_DATA.skillUpgradeCosts,
        pet:        GAME_DATA.petUpgradeCosts,
        relic:      GAME_DATA.relicUpgradeCosts,
        character:  GAME_DATA.characterUpgradeCosts,
      };
      for(const type in dataSources){
        const source = dataSources[type];
        cumulativeCostData[type] = [];
        let cumulative = {};
        if(source && source.length>0){
          Object.keys(source[0]).forEach(k=>{ if(k.startsWith('cost_')) cumulative[k] = 0; });
        }
        for(let i=0;i<(source?.length||0);i++){
          const row = source[i];
          Object.keys(cumulative).forEach(k=> cumulative[k] += (row[k]||0));
          cumulativeCostData[type].push({ level: row.level, ...cumulative });
        }
      }
    }

    // 取得指定等級的「累積」成本（若 level 不存在，回傳最近的低等級）
    function getCumulativeCost(costTable, level){
      const empty = {};
      if(!costTable || costTable.length===0) return empty;
      costTable.forEach(row => Object.keys(row).forEach(k => empty[k]=0));
      delete empty.level;
      if(level<=0) return empty;
      const idx = costTable.findLastIndex(d => d.level <= level);
      const data = (idx !== -1) ? costTable[idx] : null;
      return { ...empty, ...data };
    }

    // 成本欄位名 -> 材料鍵名（例：cost_stone_ore -> stoneOre）
    function getMaterialIdFromCostKey(costKey){
      let id = costKey.replace('cost_','');
      if(id==='stone') return 'stoneMat';
      return id.replace(/_([a-z])/g, m=>m[1].toUpperCase());
    }

    /* ---------------------------------------
     * DOM Ready：載入資料 -> 初始化 UI -> 綁事件
     * ------------------------------------- */
    document.addEventListener('DOMContentLoaded', async ()=>{
      const containers = {
        levelInputs: document.getElementById('level-inputs'),
        ownedMaterials: document.getElementById('owned-materials'),
        productionInputs: document.getElementById('production-inputs'),
        results: document.getElementById('results'),
        targetLevels: document.getElementById('target-levels'),
        relicDistributionInputs: document.getElementById('relic-distribution-inputs'),
        currentTimeDisplay: document.getElementById('current-time-display'),
      };
      
      const seasonSelector = document.getElementById('season-select');
      
      async function loadDataForSeason(seasonId) {
          const dataFiles = DATA_FILES_CONFIG[seasonId] || DATA_FILES_CONFIG.s1;
          const loadedGameData = {};
          const missingFiles = [];

          for (const key in dataFiles) {
              try {
                  loadedGameData[key] = await fetchAndParseCsv(dataFiles[key]);
              } catch (error) {
                  console.warn(`無法載入 ${dataFiles[key]}，將使用模擬數據。`, error);
                  loadedGameData[key] = MOCK_GAME_DATA[key];
                  missingFiles.push(dataFiles[key]);
              }
          }
          return { loadedGameData, missingFiles };
      }

      async function handleSeasonChange() {
          const seasonId = seasonSelector.value;
          containers.results.innerHTML = '<p class="text-gray-500 text-center py-8">正在載入新賽季數據...</p>';
          const { loadedGameData, missingFiles } = await loadDataForSeason(seasonId);
          main(loadedGameData, containers, missingFiles);
          // 儲存選擇的賽季
          const currentData = JSON.parse(localStorage.getItem('sxstxCalculatorData')) || {};
          currentData['season-select'] = seasonId;
          localStorage.setItem('sxstxCalculatorData', JSON.stringify(currentData));

      }

      seasonSelector.addEventListener('change', handleSeasonChange);

      // 初始載入
      const savedData = JSON.parse(localStorage.getItem('sxstxCalculatorData')) || {};
      seasonSelector.value = savedData['season-select'] || 's1';
      await handleSeasonChange();
    });

    /* ---------------------------------------
     * 主流程：渲染 UI、計算、事件
     * ------------------------------------- */
    function main(GAME_DATA, containers, missingFiles){
      preprocessCostData(GAME_DATA);

      // 小工具：建元素
      const el = (tag, classes=[]) => {
        const n = document.createElement(tag);
        if(classes.length) n.classList.add(...classes);
        return n;
      };

      // 輸入群組：label + input
      const createInputGroup = (id, labelText, placeholder, isSub=false, extraHtml='')=>{
        const wrap = el('div', isSub?['mb-4']:[]);
        const label = el('label', ['block','text-sm','font-bold','mb-2']);
        label.htmlFor = id; label.textContent = labelText;

        const input = el('input', ['input-field','rounded','w-full','p-2']);
        input.type = 'number'; input.id = id; input.placeholder = placeholder;

        wrap.append(label, input);
        if(extraHtml){ const div = el('div'); div.innerHTML = extraHtml; wrap.appendChild(div); }
        return wrap;
      };

      /* ========== 渲染：左欄 目前等級 ========== */
      function renderLevelInputs(){
        const frag = document.createDocumentFragment();

        // 角色（獨立一行）
        const roleTitle = el('h3',['text-lg','font-semibold','text-accent','pb-2','mb-3']);
        roleTitle.textContent = '角色等級';
        frag.appendChild(roleTitle);
        const roleRow = el('div',['grid','grid-cols-1','gap-4','mb-4','border-b','border-[#e5eff1]','pb-6']);
        const charCat = categories.find(c=>c.id==='character');
        if(charCat) roleRow.appendChild(createInputGroup(`${charCat.id}-current`, charCat.name, '目前'));
        frag.appendChild(roleRow);

        // 幻獸（一行四格）
        const petTitle = el('h3',['text-lg','font-semibold','text-accent','pb-2','mb-3']);
        petTitle.textContent = '幻獸等級';
        frag.appendChild(petTitle);
        const petRow = el('div',['grid','grid-cols-2','sm:grid-cols-4','gap-4','mb-4','border-b','border-[#e5eff1]','pb-6']);
        categories.filter(c=>c.id.startsWith('pet')).forEach(cat=>{
          petRow.appendChild(createInputGroup(`${cat.id}-current`, cat.name, '目前'));
        });
        frag.appendChild(petRow);

        // 裝備（兩欄分流）
        const equipTitle = el('h3',['text-lg','font-semibold','text-accent','pb-2','mb-3']);
        equipTitle.textContent = '裝備等級';
        frag.appendChild(equipTitle);
        const equipWrap = el('div',['grid','grid-cols-2','gap-x-6','mb-4','border-b','border-[#e5eff1]','pb-6']);
        const equipCol1 = el('div'), equipCol2 = el('div');
        categories.filter(c=>c.group==='裝備等級').forEach((cat,i)=>{
          (i<2?equipCol1:equipCol2).appendChild(createInputGroup(`${cat.id}-current`, cat.name, '目前', true));
        });
        equipWrap.append(equipCol1, equipCol2);
        frag.appendChild(equipWrap);

        // 技能（戰技 / 祕法 各一欄）
        const skillTitle = el('h3',['text-lg','font-semibold','text-accent','pb-2','mb-3']);
        skillTitle.textContent = '技能等級';
        frag.appendChild(skillTitle);
        const skillWrap = el('div',['grid','grid-cols-2','gap-x-6','mb-4','border-b','border-[#e5eff1]','pb-6']);
        const s1 = el('div'), s2 = el('div');
        categories.filter(c=>c.id.startsWith('skill_combat')).forEach(cat=> s1.appendChild(createInputGroup(`${cat.id}-current`, cat.name, '目前', true)));
        categories.filter(c=>c.id.startsWith('skill_arcane')).forEach(cat=> s2.appendChild(createInputGroup(`${cat.id}-current`, cat.name, '目前', true)));
        skillWrap.append(s1,s2);
        frag.appendChild(skillWrap);

        containers.levelInputs.appendChild(frag);
      }

      /* ========== 渲染：目標等級（六欄等寬） ========== */
      function renderTargetLevels(){
        containers.targetLevels.innerHTML = '';
        targetLevelConfig.forEach(t=>{
          const badge = (t.id==='character')
            ? `<div id="target-char-reachable-level" class="text-xs text-gray-500 mt-1">最低可達: --</div>` : '';
          const isReadOnly = t.readonly === true;
          const group = createInputGroup(`target-${t.id}`, t.name, isReadOnly? '自動計算':'目標', false, badge);

          if(isReadOnly){
            const input = group.querySelector('input');
            input.setAttribute('disabled','disabled');
            input.setAttribute('aria-readonly','true');
            const label = group.querySelector('label');
            label.insertAdjacentHTML('beforeend',
              `<span class="ml-2 text-[10px] px-1.5 py-0.5 rounded bg-amber-100 text-amber-700 align-middle">自動</span>`
            );
          }

          containers.targetLevels.appendChild(group);
        });
      }

      /* ========== 渲染：遺物分佈（10~20） ========== */
      function renderRelicDistribution(){
        for(let i=10;i<=20;i++){
          const g = createInputGroup(`relic-level-${i}`, `等級 ${i}`, '數量');
          g.querySelector('input').classList.add('relic-dist-input');
          containers.relicDistributionInputs.appendChild(g);
        }
      }

      /* ========== 渲染：右欄素材輸入 ========== */
      function renderMaterials(){
        Object.entries(materials).forEach(([id,mat])=>{
          const row = el('div',['flex','items-center']);
          const label = el('label',['w-full','block','text-sm','font-bold']);
          label.htmlFor = `owned-${id}`;
          label.textContent = `${mat.icon} ${mat.name}`;
          const input = el('input',['input-field','rounded','w-full','p-2']);
          input.type='number'; input.id=`owned-${id}`; input.placeholder='0';
          row.append(label,input);
          containers.ownedMaterials.appendChild(row);
        });
      }

      /* ========== 渲染：小推車（手動時產輸入） ========== */
      function renderProduction(){
        Object.entries(productionSources).forEach(([srcId,src])=>{
          const mat = materials[src.materialId];
          const wrap = el('div');
          const title = el('label',['block','text-sm','font-bold','mb-2']);
          title.textContent = `${mat.icon} ${mat.name}`;
          wrap.appendChild(title);

          const hourlyDiv = el('div');
          const small = el('label',['text-xs','text-gray-500']); small.textContent='時產量';
          const manual = createInputGroup(`manual-hourly-${srcId}`,'','手動輸入').querySelector('input');
          manual.classList.add('text-sm');
          hourlyDiv.append(small, manual.parentElement);
          wrap.appendChild(hourlyDiv);

          containers.productionInputs.appendChild(wrap);
        });
      }

      /* ========== 綜合渲染呼叫 ========== */
      function render(){
        // 清空容器
        Object.values(containers).forEach(c => c && (c.innerHTML=''));
        renderLevelInputs();
        renderTargetLevels();
        renderRelicDistribution();
        renderMaterials();
        renderProduction();
      }

      /* ========== 現在時間顯示（每秒更新） ========== */
      function updateCurrentTime(){
        const el = containers.currentTimeDisplay;
        if(!el) return;
        const now = new Date();
        el.textContent = now.toLocaleString('sv-SE', {
          year:'numeric', month:'2-digit', day:'2-digit',
          hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
        });
      }

      /* ========== 遺物分佈總數顯示 ========== */
      function updateRelicTotal(){
        let total = 0;
        document.querySelectorAll('.relic-dist-input').forEach(i=> total += (parseInt(i.value)||0));
        const disp = document.getElementById('relic-total-display');
        disp.textContent = `(${total}/20)`;
        if(total !== 20 && total > 0){ disp.classList.add('text-warning'); disp.classList.remove('text-gray-400'); }
        else { disp.classList.remove('text-warning'); disp.classList.add('text-gray-400'); }
      }

        /* ========== S1 賽季分數計算 ========== */
        function calculateSeasonScore_S1(targets){
            let score = 0;
            // 角色等級（S1 超過 100 等，每等換 100 賽季分數）
            if(targets.character > 100) score += (targets.character - 100) * 100;
            // 裝備共鳴（S1 超過 100 等，每等換 190 賽季分數）
            if(targets.equipment_resonance > 100) score += (targets.equipment_resonance - 100) * 190;
            // 技能共鳴（S1 超過 100 等，每等換 104 賽季分數）
            if(targets.skill_resonance > 100) score += (targets.skill_resonance - 100) * 104;
            // 幻獸共鳴（S1 超過 100 等，每等換 56 賽季分數）
            if(targets.pet_resonance > 100) score += (targets.pet_resonance - 100) * 56;
            // 遺物共鳴（S1 超過 10 等，每等換 200 賽季分數）
            if(targets.relic_resonance > 10) score += (targets.relic_resonance - 10) * 1140;
            return score;
        }

        /* ========== S1 原初之星轉換 ========== */
        function convertPrimordialStar_S1(score){
            // S1 原初之星換算公式：賽季分數 / 100 + 10 取整數
            return Math.floor(score/100 + 10);
        }

        /* ========== S2 賽季分數計算 ========== */
        function calculateSeasonScore_S2(targets){
            let score = 0;
            // 角色等級（S2 超過 100 等，每等換 120 賽季分數）
            if(targets.character > 100) score += (targets.character - 100) * 120;
            // 裝備共鳴（S2 超過 100 等，每等換 200 賽季分數）
            if(targets.equipment_resonance > 100) score += (targets.equipment_resonance - 100) * 200;
            // 技能共鳴（S2 超過 100 等，每等換 110 賽季分數）
            if(targets.skill_resonance > 100) score += (targets.skill_resonance - 100) * 110;
            // 幻獸共鳴（S2 超過 100 等，每等換 60 賽季分數）
            if(targets.pet_resonance > 100) score += (targets.pet_resonance - 100) * 60;
            // 遺物共鳴（S2 超過 10 等，每等換 1200 賽季分數）
            if(targets.relic_resonance > 10) score += (targets.relic_resonance - 10) * 1200;
            return score;
        }

      /* ========== 主計算：資源需求 / 掛機收益 / 缺口 ========== */
      function calculate(){
        let required = {};                 // 養成需求總計
        let hasError = false, hasInput = false;
        const missingDataErrors = {}; // 改為物件來追蹤每個素材的錯誤

        // 讀取「目標等級」
        const targets = {};
        targetLevelConfig.forEach(t => targets[t.id] = parseInt(document.getElementById(`target-${t.id}`).value) || 0);

        // 可達角色等級（根據目標時間與床）
        const reachableChar = document.getElementById('target-char-reachable-level');
        const curCharLv = parseInt(document.getElementById('character-current').value) || 0;
        const ownedExp = parseInt(document.getElementById('owned-exp')?.value) || 0; // 可自行加一個「目前已累積經驗」欄位
        const bedExpHourly = parseFloat(document.getElementById('bed-exp-hourly').value) || 0;
        const targetTimeStr = document.getElementById('target-time').value;

        let reachableCharLevel = curCharLv;
        if (targetTimeStr && cumulativeCostData['character']) {
          const hours = Math.max(0, (new Date(targetTimeStr).getTime() - Date.now()) / 36e5);
          const currentCum = getCumulativeCost(cumulativeCostData['character'], curCharLv - 1).cost_exp;
          const totalExp = currentCum + ownedExp + (bedExpHourly * hours);
          const idx = cumulativeCostData['character'].findLastIndex(d => d.cost_exp <= totalExp);
          reachableCharLevel = (idx !== -1) ? cumulativeCostData['character'][idx].level : curCharLv;
        }
        reachableChar.textContent = `最低可達: ${reachableCharLevel > 0 ? reachableCharLevel : '--'}`;

        // TODO: 自動計算「原初之星」等級
        const primordialStarInput = document.getElementById('target-primordial_star');
        if (primordialStarInput) {
            const relicRes = targets.relic_resonance || 0;
            // 根據賽季計算賽季分數   
            let score = 0;
            if (document.getElementById('season-select').value === 's1') {
                score = calculateSeasonScore_S1(targets);
            }
            else if (document.getElementById('season-select').value === 's2') {
                score = calculateSeasonScore_S2(targets);
            }

            // 根據賽季將賽季分數換算原初之星
            if (document.getElementById('season-select').value === 's1') {
                targets.primordial_star = convertPrimordialStar_S1(score);
            }
            else if (document.getElementById('season-select').value === 's2') {
                // S2 的換算公式待確認，暫時先用 S1 的
                targets.primordial_star = convertPrimordialStar_S1(score);
            }
            primordialStarInput.value = targets.primordial_star;
            document.getElementById('target-primordial_star').value = targets.primordial_star;

        }

        // 遺物成本（需要 20 件）
        const targetRelicResonance = targets.relic_resonance;
        let relicCount = 0;
        for(let i=10;i<=20;i++){
          const count = parseInt(document.getElementById(`relic-level-${i}`).value) || 0;
          if(count>0) hasInput = true;
          relicCount += count;

          for(let j=0;j<count;j++){
            const current = i;
            const finalTarget = Math.max(current, targetRelicResonance);
            if(finalTarget>current){
              const costTable = cumulativeCostData.relic;
              const sourceTable = GAME_DATA.relicUpgradeCosts;
              let missing = false;
              for(let lvl=current; lvl<finalTarget; lvl++){
                if(!sourceTable.find(d=>d.level===lvl)){ 
                    const errorMsg = `數據缺失: 遺物缺少 ${lvl} 級`;
                    // 遺物升級會影響 sand 和 rola
                    if (!missingDataErrors.sand) missingDataErrors.sand = errorMsg;
                    if (!missingDataErrors.rola) missingDataErrors.rola = errorMsg;
                    missing=true; 
                    break; 
                }
              }
              if(!missing && costTable){
                const start = getCumulativeCost(costTable, current - 1);
                const end   = getCumulativeCost(costTable, finalTarget - 1);
                Object.keys(end).forEach(key=>{
                  if(key.startsWith('cost_')){
                    const matId = getMaterialIdFromCostKey(key);
                    const startVal = start[key] || 0;
                    required[matId] = (required[matId]||0) + (end[key] - startVal);
                  }
                });
              }
            }
          }
        }
        if(relicCount>0 && relicCount!==20) hasError = true;

        // 角色 / 裝備 / 技能 / 幻獸成本
        categories.forEach(cat=>{
          const current = parseInt(document.getElementById(`${cat.id}-current`).value) || 0;
          if(current>0) hasInput = true;

          let targetRes = 0;
          if (cat.id === 'character') targetRes = targets.character;
          else if (cat.id.startsWith('equipment_')) targetRes = targets.equipment_resonance;
          else if (cat.id.startsWith('skill_'))     targetRes = targets.skill_resonance;
          else if (cat.id.startsWith('pet'))        targetRes = targets.pet_resonance;

          const finalTarget = Math.max(current, targetRes);
          if(finalTarget>current){
            let costTable, sourceTable, itemName, affectedMats = [];
            if (cat.id.startsWith('equipment_')) { 
                costTable=cumulativeCostData.equipment; 
                sourceTable=GAME_DATA.equipmentUpgradeCosts; 
                itemName='裝備';
                affectedMats = ['stoneOre', 'rola', 'refiningStone'];
            }
            else if (cat.id.startsWith('skill_')) { 
                costTable=cumulativeCostData.skill;     
                sourceTable=GAME_DATA.skillUpgradeCosts;     
                itemName='技能';
                affectedMats = ['essence'];
            }
            else if (cat.id.startsWith('pet'))    { 
                costTable=cumulativeCostData.pet;       
                sourceTable=GAME_DATA.petUpgradeCosts;       
                itemName='幻獸';
                affectedMats = ['freezeDried'];
            }
            else { 
                costTable=cumulativeCostData[cat.id]; 
                sourceTable=GAME_DATA.characterUpgradeCosts; 
                itemName='角色';
                affectedMats = ['exp'];
            }

            let missing=false;
            if(sourceTable){
              for(let lvl=current; lvl<finalTarget; lvl++){
                if(!sourceTable.find(d=>d.level===lvl)){ 
                    const errorMsg = `數據缺失: ${itemName}缺少 ${lvl} 級`;
                    affectedMats.forEach(matId => {
                        if (!missingDataErrors[matId]) missingDataErrors[matId] = errorMsg;
                    });
                    missing=true; 
                    break; 
                }
              }
            }
            if(!missing && costTable){
              const start = getCumulativeCost(costTable, current - 1);
              const end   = getCumulativeCost(costTable, finalTarget - 1);
              Object.keys(end).forEach(key=>{
                if(key.startsWith('cost_')){
                  const matId = getMaterialIdFromCostKey(key);
                  const startVal = start[key] || 0;
                  required[matId] = (required[matId]||0) + (end[key] - startVal);
                }
              });
            }
          }
        });

        // 異常回報
        if (hasError){
          containers.results.innerHTML = '<p class="text-warning text-center py-4">輸入有誤 (例如遺物總數不為20)，請檢查。</p>';
          return;
        }
        if(!hasInput){ renderResults({}, {}, {}, {}, missingDataErrors); return; }

        // 掛機收益（依目標時間；本版只使用「手動時產」）
        const gainsFromTime = {};
        if(targetTimeStr){
          const hours = Math.max(0, (new Date(targetTimeStr).getTime() - Date.now()) / 36e5);
          for(const srcId in productionSources){
            const manual = parseFloat(document.getElementById(`manual-hourly-${srcId}`)?.value) || 0;
            gainsFromTime[productionSources[srcId].materialId] =
              (gainsFromTime[productionSources[srcId].materialId]||0) + Math.floor(manual * hours);
          }
          const bedPerHour = parseFloat(document.getElementById('bed-exp-hourly').value) || 0;
          if(bedPerHour>0) gainsFromTime['exp'] = (gainsFromTime['exp']||0) + Math.floor(bedPerHour * hours);
        }

        // 缺口 = 需求 - (持有 + 掛機)
        const deficit = {};
        for(const matId in materials){
          const need = required[matId] || 0;
          const owned = parseInt(document.getElementById(`owned-${matId}`)?.value) || 0;
          const gained = gainsFromTime[matId] || 0;
          deficit[matId] = Math.max(0, need - owned - gained);
        }

        // 更新升級時間與通知
        updateLevelUpTimeAndNotification(curCharLv, ownedExp, parseFloat(document.getElementById('bed-exp-hourly').value)||0);

        // 輸出結果
        renderResults(required, {}, gainsFromTime, deficit, missingDataErrors);
      }

      /* ========== 升級時間 + 推播排程 ========== */
      function updateLevelUpTimeAndNotification(currentLevel, ownedExp, bedExpHourly){
        const disp = document.getElementById('bed-levelup-time');
        if(notificationTimerId){ clearTimeout(notificationTimerId); notificationTimerId = null; }
        if (bedExpHourly <= 0 || currentLevel >= MAX_LEVEL) { disp.textContent = '預計升級時間: --'; return; }
        const nextCumData = cumulativeCostData['character'].find(d => d.level === currentLevel);
        const curCumData = getCumulativeCost(cumulativeCostData['character'], currentLevel - 1);
        if (!nextCumData) { disp.textContent = '已達最高等級'; return; }
        
        const nextLvlExpCost = nextCumData.cost_exp - curCumData.cost_exp;
        const expNeeded = Math.max(0, nextLvlExpCost - (Number(ownedExp)||0));
        let levelupTs = NaN;

        if(expNeeded <= 0){
          disp.textContent = '預計升級時間: 可立即升級';
        }else{
          const ratePerHour = Number(bedExpHourly);
          if(!Number.isFinite(ratePerHour) || ratePerHour<=0){
            disp.textContent = '預計升級時間: 請先輸入床的每小時經驗產量';
          }else{
            const ratePerSec = ratePerHour / 3600;
            const secondsNeeded = Math.ceil(expNeeded / ratePerSec);
            const minutesNeeded = Math.ceil(secondsNeeded / 60);
            levelupTs = Date.now() + minutesNeeded * 60 * 1000;
            const timeStr = new Date(levelupTs).toLocaleString('zh-TW', {
              year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'
            });
            disp.textContent = `預計升級時間: ${timeStr}（約 ${minutesNeeded.toLocaleString()} 分鐘）`;
          }
        }

        if ('Notification' in window && Notification.permission === 'granted') {
          if (bedExpHourly > 0 && expNeeded > 0 && Number.isFinite(levelupTs) && levelupTs > Date.now()) {
            const alignedLvTs = Math.ceil(levelupTs / 60000) * 60000;
            const notifyAt = alignedLvTs - 3 * 60 * 1000;
            const delay = notifyAt - Date.now();
            if (delay > 0) {
              const MAX_DELAY = 0x7fffffff; // ~24.8 天
              const schedule = (ms)=>{
                if(ms > MAX_DELAY){
                  notificationTimerId = setTimeout(()=>schedule(ms - MAX_DELAY), MAX_DELAY);
                }else{
                  notificationTimerId = setTimeout(()=>{
                    new Notification('杖劍傳說提醒', {
                      body:`您的角色約 3 分鐘後可升級至 ${currentLevel + 1} 級！`,
                      icon:'https://placehold.co/192x192/31c9be/ffffff?text=LV'
                    });
                    notificationTimerId = null;
                  }, ms);
                }
              };
              schedule(delay);
            }
          }
        }
      }

      /* ========== 結果輸出（右下卡片） ========== */
      function renderResults(req, prodCost, gains, deficit, materialErrors = {}){
        let html = '';
        if (missingFiles.length > 0){
          html += `<div class="bg-yellow-900/50 border-l-4 border-yellow-400 text-yellow-300 p-3 rounded-lg mb-4 text-sm">
                    <h4 class="font-bold">注意</h4>
                    <p>無法載入以下數據檔案，已使用模擬數據：<br>${missingFiles.join(', ')}</p>
                   </div>`;
        }
        
        const fmt = n => n.toLocaleString();
        const displayOrder = ['rola', 'essence', 'sand', 'stoneOre', 'freezeDried'];

        const grid = el('div', ['grid', 'grid-cols-1', 'md:grid-cols-2', 'gap-4']);
        
        displayOrder.forEach(matId => {
            const mat = materials[matId];
            const card = el('div', ['p-4', 'rounded-lg', 'result-item']);
            let cardContent = `
                <div class="flex justify-between items-center mb-2">
                    <h4 class="font-bold text-gold flex items-center">
                        <span class="text-2xl mr-2">${mat.icon}</span>
                        <span>${mat.name}</span>
                    </h4>
                </div>`;

            if (materialErrors[matId]) {
                cardContent += `<div class="text-warning text-sm font-semibold">${materialErrors[matId]}</div>`;
            } else {
                const requiredAmount = req[matId] || 0;
                const deficitAmount = deficit[matId] || 0;
                const neededText = deficitAmount > 0 
                    ? `<strong class="text-warning">-${fmt(deficitAmount)}</strong>` 
                    : '<span class="text-green-400">充足</span>';

                cardContent += `
                    <div class="space-y-1 text-sm">
                        <div class="flex justify-between"><span>總共需要:</span> <strong>${fmt(requiredAmount)}</strong></div>
                        <div class="flex justify-between"><span>還缺少:</span> ${neededText}</div>
                    </div>`;
            }
            card.innerHTML = cardContent;
            grid.appendChild(card);
        });
        
        containers.results.innerHTML = ''; // 清空
        containers.results.appendChild(grid);

        // 如果沒有任何輸入，顯示提示
        if(Object.keys(req).length === 0 && Object.keys(deficit).length === 0 && Object.keys(materialErrors).length === 0) {
            containers.results.innerHTML = html + '<p class="text-gray-500 text-center py-8">請輸入資料以自動計算。</p>';
        } else if (html) {
            containers.results.insertAdjacentHTML('afterbegin', html);
        }
      }

      /* ========== 事件綁定 ========== */
      function setupEventListeners(){
        // 任一數值/時間改變就重新計算
        document.body.addEventListener('input', e=>{
          const t = e.target;
          if (t.matches('input[type=number], input[type=datetime-local]')) {
            if (t.classList.contains('relic-dist-input')) updateRelicTotal();
            calculate();
            saveData();
          }
        });

        // 啟用通知
        const notifBtn = document.getElementById('enable-notifications-btn');
        if('Notification' in window){
          notifBtn.addEventListener('click', ()=>{
            Notification.requestPermission().then(p=>{
              if(p==='granted'){
                notifBtn.textContent = '通知已啟用';
                notifBtn.disabled = true;
                new Notification('通知已啟用',{ body:'角色升級前 3 分鐘將提醒您！' });
              }else{
                notifBtn.textContent = '通知被拒絕'; notifBtn.disabled = true;
              }
            });
          });
        }else{
          notifBtn.textContent = '瀏覽器不支援通知'; notifBtn.disabled = true;
        }
        
        // 清除本地紀錄
        const clearBtn = document.getElementById('clear-data-btn');
        clearBtn.addEventListener('click', ()=>{
            if(confirm('確定要清除所有已儲存的本地紀錄嗎？此操作無法復原。')){
                localStorage.removeItem('sxstxCalculatorData');
                location.reload();
            }
        });
      }
      
      /**
       * @description 將所有輸入欄位的資料儲存到 localStorage
       */
      function saveData() {
        const data = {};
        document.querySelectorAll('input[type=number], input[type=datetime-local], select').forEach(input => {
            if (input.id) {
                data[input.id] = input.value;
            }
        });
        localStorage.setItem('sxstxCalculatorData', JSON.stringify(data));
      }

      /**
       * @description 從 localStorage 讀取資料並填入欄位
       */
      function loadData() {
        const savedData = localStorage.getItem('sxstxCalculatorData');
        if (savedData) {
            const data = JSON.parse(savedData);
            Object.keys(data).forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.value = data[id];
                }
            });
        }
      }

      // ---- 啟動流程 ----
      render();
      setupEventListeners();
      loadData();
      updateRelicTotal();
      setInterval(updateCurrentTime, 1000);
      updateCurrentTime();
      calculate(); // 初始化計算一次
    }
  </script>
</body>
</html>

