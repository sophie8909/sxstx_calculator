<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–åŠå‚³èªª ç´ æè¨ˆç®—æ©Ÿ</title>
    <!-- tailwindcss CDN only for local / testing use -->
    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
    body {
        font-family: 'Noto Sans TC', sans-serif;
        background: linear-gradient(180deg, #f5fafb 0%, #e6f3f4 100%);
        color: #1e293b; /* æ·±è—ç°æ–‡å­— */
    }

    .card {
        background: #ffffffd9; /* åŠé€æ˜ç™½å¡ç‰‡ */
        border: 1px solid #cde5e8;
        box-shadow: 0 2px 8px rgba(38, 115, 119, 0.15);
        border-radius: 10px;
        transition: all 0.25s ease;
    }

    .input-field {
        background-color: #f7fbfc;
        color: #1e293b;
        border: 1px solid #b6d7da;
        transition: border-color 0.25s, box-shadow 0.25s, background-color 0.25s;
    }

    .input-field:focus {
        border-color: #2cb5ab;
        box-shadow: 0 0 6px rgba(44, 181, 171, 0.4);
        outline: none;
        background-color: #f0fafa;
    }

    .input-field:disabled {
        background-color: #eef3f4;
        color: #94a3b8;
        border-color: #cbd5e1;
        cursor: not-allowed;
    }

    .btn-primary {
        background: linear-gradient(135deg, #31c9be 0%, #1a9e95 100%);
        color: #fffef8;
        border: 1px solid #21b8ac;
        box-shadow: 0 2px 6px rgba(34, 180, 168, 0.25);
        transition: background 0.3s, transform 0.15s;
    }

    .btn-primary:hover {
        background: linear-gradient(135deg, #45dfd3 0%, #23b7ac 100%);
        transform: translateY(-2px);
    }

    .result-item {
        background-color: #fffdf5;
        border-left: 4px solid #f48b45; /* æˆæœ¬ï¼ç¼ºå£ï¼šæ©˜é‡‘ */
        box-shadow: inset 0 0 8px rgba(244, 139, 69, 0.2);
    }

    .info-item {
        background-color: #f0faf9;
        border-left: 4px solid #2cb5ab; /* è³‡è¨Šï¼šé’ç¶  */
        box-shadow: inset 0 0 8px rgba(44, 181, 171, 0.15);
    }

    .cost-item {
        background-color: #fffbee;
        border-left: 4px solid #facc15; /* é»ƒé‡‘äº®é‚Š */
        box-shadow: inset 0 0 8px rgba(249, 209, 98, 0.2);
    }

    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
        opacity: 0.4;
    }

    /* æ»¾å‹•æ¢ */
    .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: #f2f8f9; }
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #b3dede 0%, #89cfcf 100%);
        border-radius: 4px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, #6dcacb 0%, #4fbebf 100%);
    }

    /* æ¨™é¡Œå­—è‰²èˆ‡é‡é»è‰² */
    h1, h2, h3, h4 {
        color: #165f63; /* æ·±é’æ¨™é¡Œ */
        text-shadow: 0 1px 2px rgba(22, 95, 99, 0.15);
    }
    .text-accent { color: #1fb7ad; }
    .text-gold { color: #d4a418; }
    .text-warning { color: #d65a2d; }

    /* å¡ç‰‡ hover æ•ˆæœ */
    .card:hover {
        box-shadow: 0 4px 14px rgba(43, 184, 172, 0.25);
        border-color: #21b8ac;
        transform: translateY(-2px);
    }
</style>


</head>
<body class="p-4 lg:p-6">

    <div class="w-full max-w-7xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold ">æ–åŠå‚³èªª ç´ æè¨ˆç®—æ©Ÿ</h1>
        </header>

        <div class="card rounded-lg p-4 shadow-lg mb-6 max-w-lg mx-auto">
            <div class="flex items-center justify-center gap-x-6">
                <div>
                    <h3 class="text-lg font-semibold text-center mb-2">ç›®æ¨™æ™‚é–“</h3>
                    <input type="datetime-local" id="target-time" class="input-field rounded w-full py-2 px-3">
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-center mb-2">ç¾åœ¨æ™‚é–“</h3>
                    <div id="current-time-display" class="text-center bg-gray-900/50 p-2 rounded h-[42px] flex items-center justify-center min-w-[210px] text-[#e2e8f0]">
                        <!-- JS will populate this -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card rounded-lg p-6 shadow-lg mb-6 max-w-6xl mx-auto">
            <h3 class="text-xl font-bold text-center mb-4">ç›®æ¨™ç­‰ç´š (å…±é³´)</h3>
            <div id="target-levels" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-6 gap-4">
                <!-- JS will populate this -->
            </div>
        </div>
        
        <div class="card rounded-lg p-6 shadow-lg mb-6 max-w-6xl mx-auto">
            <h3 class="text-xl font-bold text-center mb-4">éºç‰©ç­‰ç´šåˆ†ä½ˆ <span id="relic-total-display" class="text-sm font-normal text-gray-400">(0/20)</span></h3>
            <div id="relic-distribution-inputs" class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-11 gap-x-6 gap-y-4">
                <!-- JS will populate this -->
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <div class="card rounded-xl p-0 shadow-lg max-h-[75vh] flex flex-col">
                <!-- æ¨™é¡Œï¼šsticky + æ·ºè‰²èƒŒæ™¯ + æŸ”å’Œé‚Šç·š -->
                <h2
                    class="text-2xl font-bold border-b pb-3 sticky top-0 z-10
                        px-6 py-3 m-0
                        bg-white/90 backdrop-blur
                        border-[#cde5e8]">
                    è§’è‰²ç›®å‰ç­‰ç´š
                </h2>

                <!-- å…§å®¹ï¼šåªæœ‰é€™å±¤æ»¾å‹•ï¼›ç§»é™¤é‡è¤‡çš„ max-hï¼Œé¿å…é›™é‡æ²å‹• -->
                <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
                    <div id="level-inputs" class="pt-2"></div>
                </div>
            </div>


            
            <div class="card rounded-xl p-0 shadow-lg max-h-[75vh] flex flex-col">
                <h2
                    class="text-2xl font-bold border-b pb-3 sticky top-0 z-10
                        px-6 py-3 m-0
                        bg-white/90 backdrop-blur
                        border-[#cde5e8]">
                    å°æ¨è»Š
                </h2>

                <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
                    <div id="production-inputs" class="space-y-6 mb-6"></div>
                    <h3 class="text-lg font-semibold pt-4 border-t border-[#e5eff1]">å…¨åŸŸåŠ æˆ (%)</h3>
                    <div id="global-bonuses" class="grid grid-cols-3 gap-4 mt-4"></div>
                </div>
            </div>


            <div class="flex flex-col gap-6">
                <div class="card rounded-xl p-0 shadow-lg max-h-[40vh] flex flex-col">
                    <h2
                        class="text-2xl font-bold border-b pb-3 sticky top-0 z-10
                            px-6 py-3 m-0
                            bg-white/90 backdrop-blur
                            border-[#cde5e8]">
                        ç´ æè³‡è¨Š
                    </h2>

                    <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
                        <div class="pt-2 mb-6 border-b border-[#e5eff1] pb-6">
                        <h3 class="text-lg font-semibold text-accent mb-3">åºŠ</h3>
                        <div class="flex items-center">
                            <label for="bed-exp-hourly" class="w-full block text-sm font-bold">ğŸ“– æ¯å°æ™‚ç¶“é©—ç”¢é‡</label>
                            <input type="number" id="bed-exp-hourly" placeholder="0" class="input-field rounded w-full p-2">
                        </div>
                        <div id="bed-levelup-time" class="text-xs text-gray-500 mt-2">é è¨ˆå‡ç´šæ™‚é–“: --</div>
                        </div>

                        <h3 class="text-lg font-semibold text-accent mb-3">ç›®å‰æŒæœ‰ç´ æ</h3>
                        <div id="owned-materials" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-1 gap-4"></div>
                    </div>
                </div>

                <div class="card rounded-xl p-0 shadow-lg max-h-[43.5vh] flex flex-col">
                    <h2
                        class="text-2xl font-bold border-b pb-3 sticky top-0 z-10
                            px-6 py-3 m-0
                            bg-white/90 backdrop-blur
                            border-[#cde5e8]">
                        è¨ˆç®—ç¸½è¦½
                    </h2>

                    <div class="overflow-y-auto custom-scrollbar p-6 min-h-0">
                        <div id="results" class="space-y-4 pt-2">
                        <p class="text-gray-500 text-center py-8">æ­£åœ¨è¼‰å…¥éŠæˆ²æ•¸æ“š...</p>
                        </div>
                    </div>
                </div>

            </div>
        </div>
        
        <footer class="text-center text-gray-500 mt-10 text-sm">
            <!-- <p>é‡è¦ï¼šè«‹å°‡æ‰€æœ‰ .csv æª”æ¡ˆèˆ‡æ­¤ HTML æª”æ¡ˆæ”¾åœ¨åŒä¸€å€‹è³‡æ–™å¤¾ï¼Œä¸¦é€éæœ¬åœ°ä¼ºæœå™¨ (Local Server) ç€è¦½ã€‚</p> -->
            <button id="enable-notifications-btn" class="mt-4 bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg text-xs">å•Ÿç”¨å‡ç´šé€šçŸ¥</button>
        </footer>
    </div>

    <script>
        // --- æ ¸å¿ƒæ‡‰ç”¨ç¨‹å¼è¨­å®š (Core Application Settings) ---
        const MAX_LEVEL = 200; // æœ€é«˜ç­‰ç´šä¸Šé™
        let notificationTimerId = null; // ç”¨æ–¼å­˜æ”¾é€šçŸ¥çš„è¨ˆæ™‚å™¨ID

        // å®šç¾©æ‰€æœ‰éœ€è¦è¼¸å…¥ç›®å‰ç­‰ç´šçš„é …ç›®ï¼Œç”¨æ–¼ç”Ÿæˆå·¦å´æ¬„ä½
        const categories = [
            { id: 'character', name: 'è§’è‰²ç­‰ç´š' },
            { id: 'equipment_main_weapon', name: 'ä¸»æ­¦å™¨', group: 'è£å‚™ç­‰ç´š' },
            { id: 'equipment_off_weapon', name: 'å‰¯æ­¦å™¨', group: 'è£å‚™ç­‰ç´š' },
            { id: 'equipment_helmet', name: 'é ­ç›”', group: 'è£å‚™ç­‰ç´š' },
            { id: 'equipment_armor', name: 'é§ç”²', group: 'è£å‚™ç­‰ç´š' },
            { id: 'equipment_boots', name: 'æˆ°é´', group: 'è£å‚™ç­‰ç´š' },
            { id: 'skill_combat1', name: 'æˆ°æŠ€ä¸€', group: 'æŠ€èƒ½ç­‰ç´š' },
            { id: 'skill_combat2', name: 'æˆ°æŠ€äºŒ', group: 'æŠ€èƒ½ç­‰ç´š' },
            { id: 'skill_combat3', name: 'æˆ°æŠ€ä¸‰', group: 'æŠ€èƒ½ç­‰ç´š' },
            { id: 'skill_combat4', name: 'æˆ°æŠ€å››', group: 'æŠ€èƒ½ç­‰ç´š' },
            { id: 'skill_arcane1', name: 'ç¥•æ³•ä¸€', group: 'æŠ€èƒ½ç­‰ç´š' },
            { id: 'skill_arcane2', name: 'ç¥•æ³•äºŒ', group: 'æŠ€èƒ½ç­‰ç´š' },
            { id: 'skill_arcane3', name: 'ç¥•æ³•ä¸‰', group: 'æŠ€èƒ½ç­‰ç´š' },
            { id: 'skill_arcane4', name: 'ç¥•æ³•å››', group: 'æŠ€èƒ½ç­‰ç´š' },
            { id: 'pet1', name: 'å¹»ç¸ä¸€', group: 'å¹»ç¸ç­‰ç´š' },
            { id: 'pet2', name: 'å¹»ç¸äºŒ', group: 'å¹»ç¸ç­‰ç´š' },
            { id: 'pet3', name: 'å¹»ç¸ä¸‰', group: 'å¹»ç¸ç­‰ç´š' },
            { id: 'pet4', name: 'å¹»ç¸å››', group: 'å¹»ç¸ç­‰ç´š' },
        ];

        // å®šç¾©é ‚éƒ¨çš„ç›®æ¨™ç­‰ç´šè¨­å®šæ¬„ä½
        const targetLevelConfig = [
            { id: 'character', name: 'è§’è‰²ç­‰ç´š' },
            { id: 'equipment_resonance', name: 'è£å‚™å…±é³´' },
            { id: 'skill_resonance', name: 'æŠ€èƒ½å…±é³´' },
            { id: 'pet_resonance', name: 'å¹»ç¸å…±é³´' },
            { id: 'relic_resonance', name: 'éºç‰©å…±é³´' },
        ];

        // å®šç¾©æ‰€æœ‰éŠæˆ²å…§çš„ç´ æåŠå…¶åœ–ç¤º
        const materials = {
            exp: { name: 'è§’è‰²ç¶“é©—', icon: 'ğŸ“–' },
            rola: { name: 'ç¾…æ‹‰å¹£', icon: 'ğŸ’°' },
            wood: { name: 'æœ¨é ­', icon: 'ğŸªµ' },
            stoneMat: { name: 'çŸ³é ­', icon: 'ğŸª¨' },
            essence: { name: 'æ­·æˆ°ç²¾è¯', icon: 'âœ¨' },
            sand: { name: 'æ™‚ä¹‹ç ‚', icon: 'â³' },
            stoneOre: { name: 'ç²—ç…‰çŸ³', icon: 'ğŸ’' },
            refiningStone: { name: 'ç²¾ç…‰çŸ³', icon: 'ğŸ”¨' },
            freezeDried: { name: 'å¹»ç¸å‡ä¹¾', icon: 'ğŸ–' },
        };

        // å®šç¾©æ¨è»Šå¯ç”Ÿç”¢çš„è³‡æºåŠå…¶åŸºç¤ç”¢é‡å…¬å¼
        const productionSources = {
            // TODO: [éŠæˆ²æ•¸æ“š] æ­¤è™•ç‚ºå„è³‡æºçš„åŸºç¤ç”¢é‡å…¬å¼ï¼Œè«‹æ ¹æ“šéŠæˆ²å¯¦éš›æƒ…æ³ä¿®æ”¹
            rola: { materialId: 'rola', baseProd: (lv) => 100 * Math.pow(lv, 1.5) },
            wood: { materialId: 'wood', baseProd: (lv) => 120 * Math.pow(lv, 1.45) },
            stoneMat: { materialId: 'stoneMat', baseProd: (lv) => 110 * Math.pow(lv, 1.48) },
            essence: { materialId: 'essence', baseProd: (lv) => 50 * Math.pow(lv, 1.6) },
            stoneOre: { materialId: 'stoneOre', baseProd: (lv) => 40 * Math.pow(lv, 1.65) },
            sand: { materialId: 'sand', baseProd: (lv) => 20 * Math.pow(lv, 1.3) },
            freezeDried: { materialId: 'freezeDried', baseProd: (lv) => 30 * Math.pow(lv, 1.4) }
        };

        // å®šç¾©å…¨åŸŸåŠ æˆçš„é …ç›®
        const globalBonuses = {
            map: { name: 'æ¨åœ–é€²åº¦' },
            relic: { name: 'å¤éºç‰©' },
            pass: { name: 'æœˆå¡' }
        };

        // ç”¨æ–¼å„²å­˜é è™•ç†å¾Œçš„ç´¯ç©æˆæœ¬æ•¸æ“š
        const cumulativeCostData = {};
        
        // å…§å»ºçš„å‚™ç”¨æ¨¡æ“¬æ•¸æ“šï¼Œç•¶ CSV æª”æ¡ˆè¼‰å…¥å¤±æ•—æ™‚ä½¿ç”¨
        const MOCK_GAME_DATA = {
            // [æ¨¡æ“¬æ•¸æ“š] ä»¥ä¸‹ç‚º CSV è®€å–å¤±æ•—æ™‚çš„å‚™ç”¨æ•¸æ“š
            productionUpgradeCosts: [ { level: 1, cost_wood: 100, cost_stone: 100, cost_rola: 500 }, { level: 2, cost_wood: 200, cost_stone: 200, cost_rola: 1000 }, { level: 3, cost_wood: 400, cost_stone: 400, cost_rola: 2000 }, ],
            equipmentUpgradeCosts: [ { level: 1, cost_stone_ore: 10, cost_rola: 100, cost_refining_stone: 0 }, { level: 2, cost_stone_ore: 20, cost_rola: 200, cost_refining_stone: 0 }, { level: 30, cost_stone_ore: 500, cost_rola: 5000, cost_refining_stone: 1 }, ],
            skillUpgradeCosts: [ { level: 1, cost_essence: 50 }, { level: 2, cost_essence: 75 }, { level: 3, cost_essence: 100 }, ],
            petUpgradeCosts: [ { level: 1, cost_freeze_dried: 30 }, { level: 2, cost_freeze_dried: 45 }, { level: 3, cost_freeze_dried: 60 }, ],
            relicUpgradeCosts: [ { level: 1, cost_sand: 100, cost_rola: 1000 }, { level: 2, cost_sand: 150, cost_rola: 1500 }, { level: 3, cost_sand: 200, cost_rola: 2000 }, ],
            characterUpgradeCosts: Array.from({ length: MAX_LEVEL }, (_, i) => ({ level: i + 1, cost_exp: Math.floor(200 * Math.pow(i + 1, 2.2)) })),
        };

        /**
         * @description å¾æŒ‡å®šçš„ URL ç²å–ä¸¦è§£æ CSV æª”æ¡ˆã€‚
         * @param {string} url - CSV æª”æ¡ˆçš„è·¯å¾‘ã€‚
         * @returns {Promise<Array<Object>>} - è§£æå¾Œçš„ç‰©ä»¶é™£åˆ—ã€‚
         */
        async function fetchAndParseCsv(url) {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`ç„¡æ³•è¼‰å…¥ CSV æª”æ¡ˆ: ${url}`);
            }
            const csvText = await response.text();
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            return lines.slice(1).map(line => {
                const values = line.split(',').map(v => v.trim());
                const obj = {};
                headers.forEach((header, i) => {
                    const value = parseFloat(values[i]);
                    obj[header] = isNaN(value) ? 0 : value;
                });
                return obj;
            });
        }

        /**
         * @description é è™•ç† GAME_DATA ä¸­çš„æˆæœ¬æ•¸æ“šï¼Œè½‰æ›ç‚ºç´¯ç©æˆæœ¬è¡¨ã€‚
         * @param {Object} GAME_DATA - åŒ…å«æ‰€æœ‰å¾ CSV æˆ–æ¨¡æ“¬æ•¸æ“šä¾†çš„æˆæœ¬è³‡æ–™ã€‚
         */
        function preprocessCostData(GAME_DATA) {
            const dataSources = {
                equipment: GAME_DATA.equipmentUpgradeCosts, skill: GAME_DATA.skillUpgradeCosts, pet: GAME_DATA.petUpgradeCosts,
                relic: GAME_DATA.relicUpgradeCosts, production: GAME_DATA.productionUpgradeCosts,
                character: GAME_DATA.characterUpgradeCosts,
            };
            // [è¨ˆç®—] æ­¤è¿´åœˆè™•ç†æ‰€æœ‰å¾ CSV è®€å–çš„æ•¸æ“šï¼Œå°‡å…¶è½‰æ›ç‚ºè¨ˆç®—æ©Ÿå…§éƒ¨ä½¿ç”¨çš„ã€Œç´¯ç©æˆæœ¬ã€æ ¼å¼ã€‚
            for (const type in dataSources) {
                const source = dataSources[type];
                cumulativeCostData[type] = [];
                let cumulative = {};
                if (source && source.length > 0) { Object.keys(source[0]).forEach(key => { if (key.startsWith('cost_')) cumulative[key] = 0; }); }
                for (let i = 0; i < source.length; i++) {
                    const levelData = source[i];
                    Object.keys(cumulative).forEach(key => { cumulative[key] += (levelData[key] || 0); });
                    cumulativeCostData[type].push({ level: levelData.level, ...cumulative });
                }
            }
        }

        /**
         * @description å¾æŒ‡å®šçš„ç´¯ç©æˆæœ¬è¡¨ä¸­ï¼Œç²å–æŸå€‹ç­‰ç´šçš„ç¸½æˆæœ¬ã€‚
         * @param {Array} costTable - é è™•ç†éçš„ç´¯ç©æˆæœ¬è¡¨ã€‚
         * @param {number} level - æƒ³è¦æŸ¥è©¢çš„ç­‰ç´šã€‚
         * @returns {Object} åŒ…å«è©²ç­‰ç´šæ‰€æœ‰ç´¯ç©æˆæœ¬çš„ç‰©ä»¶ã€‚
         */
        function getCumulativeCost(costTable, level) {
            // [è¨ˆç®—] é€™æ˜¯ç²å–ç´¯ç©ç¶“é©—/è³‡æºçš„æ ¸å¿ƒé‚è¼¯ã€‚
            const emptyCost = {};
            if (!costTable || costTable.length === 0) return emptyCost;
            costTable.forEach(row => {
                Object.keys(row).forEach(key => emptyCost[key] = 0);
            });
            delete emptyCost.level;
            if (level <= 0) return emptyCost;
            const index = costTable.findLastIndex(d => d.level <= level);
            const data = (index !== -1) ? costTable[index] : null;
            return { ...emptyCost, ...data };
        }

        /**
         * @description å°‡ CSV æ¨™é ­ä¸­çš„æˆæœ¬éµå (å¦‚ cost_stone_ore) è½‰æ›ç‚º materials ç‰©ä»¶ä¸­çš„éµå (stoneOre)ã€‚
         * @param {string} costKey - æˆæœ¬éµåã€‚
         * @returns {string} è½‰æ›å¾Œçš„ææ–™ IDã€‚
         */
        function getMaterialIdFromCostKey(costKey) {
            let matId = costKey.replace('cost_', '');
            if (matId === 'stone') return 'stoneMat';
            return matId.replace(/_([a-z])/g, g => g[1].toUpperCase());
        }

        // ç•¶æ•´å€‹ç¶²é æ–‡ä»¶ï¼ˆDOMï¼‰è¼‰å…¥å®Œæˆå¾Œï¼Œé–‹å§‹åŸ·è¡Œä¸»ç¨‹å¼
        document.addEventListener('DOMContentLoaded', async () => {
            const containers = {
                levelInputs: document.getElementById('level-inputs'), ownedMaterials: document.getElementById('owned-materials'),
                productionInputs: document.getElementById('production-inputs'), globalBonuses: document.getElementById('global-bonuses'),
                results: document.getElementById('results'), targetLevels: document.getElementById('target-levels'),
                relicDistributionInputs: document.getElementById('relic-distribution-inputs'),
                currentTimeDisplay: document.getElementById('current-time-display'),
            };
            const dataFiles = {
                productionUpgradeCosts: 'production_upgrade_costs.csv',
                equipmentUpgradeCosts: 'equipment_upgrade_costs.csv',
                skillUpgradeCosts: 'skill_upgrade_costs.csv',
                petUpgradeCosts: 'pet_upgrade_costs.csv',
                relicUpgradeCosts: 'relic_upgrade_costs.csv',
                characterUpgradeCosts: 'character_upgrade_costs.csv'
            };
            const loadedGameData = {};
            const missingFiles = [];
            // å˜—è©¦è¼‰å…¥æ‰€æœ‰ CSVï¼Œè‹¥å¤±æ•—å‰‡ä½¿ç”¨æ¨¡æ“¬æ•¸æ“šä¸¦è¨˜éŒ„æª”å
            for (const key in dataFiles) {
                try {
                    loadedGameData[key] = await fetchAndParseCsv(dataFiles[key]);
                } catch (error) {
                    console.warn(`ç„¡æ³•è¼‰å…¥ ${dataFiles[key]}ï¼Œå°‡ä½¿ç”¨æ¨¡æ“¬æ•¸æ“šã€‚`, error);
                    loadedGameData[key] = MOCK_GAME_DATA[key];
                    missingFiles.push(dataFiles[key]);
                }
            }
            // é€²å…¥ä¸»ç¨‹å¼é‚è¼¯
            main(loadedGameData, containers, missingFiles);
        });

        /**
         * @description ä¸»æ‡‰ç”¨ç¨‹å¼é‚è¼¯ï¼Œåœ¨æ•¸æ“šè¼‰å…¥å¾ŒåŸ·è¡Œã€‚
         * @param {Object} GAME_DATA - è¼‰å…¥æˆ–æ¨¡æ“¬çš„éŠæˆ²æ•¸æ“šã€‚
         * @param {Object} containers - é é¢ä¸Šçš„ DOM å…ƒç´ å®¹å™¨ã€‚
         * @param {Array<string>} missingFiles - è¼‰å…¥å¤±æ•—çš„ CSV æª”ååˆ—è¡¨ã€‚
         */
        function main(GAME_DATA, containers, missingFiles) {
            preprocessCostData(GAME_DATA);
            
            /**
             * @description æ ¹æ“šè¨­å®šæª”ï¼Œå‹•æ…‹ç”Ÿæˆæ•´å€‹è¨ˆç®—æ©Ÿçš„ HTML ä»‹é¢ã€‚
             */
            function render() {
                // --- æ¸…ç©ºæ‰€æœ‰å®¹å™¨ ---
                Object.values(containers).forEach(container => { if (container) container.innerHTML = ''; });

                // --- è¼”åŠ©å‡½å¼ï¼šå‰µå»ºå¸¶æœ‰ class çš„å…ƒç´  ---
                const createElement = (tag, classes = []) => {
                    const el = document.createElement(tag);
                    if (classes.length > 0) el.classList.add(...classes);
                    return el;
                };

                // --- è¼”åŠ©å‡½å¼ï¼šå‰µå»ºä¸€å€‹å®Œæ•´çš„è¼¸å…¥æ¡†ç¾¤çµ„ ---
                const createInputGroup = (id, labelText, placeholder, isSub = false, additionalHtml = '') => {
                    const wrapper = createElement('div', isSub ? ['mb-4'] : []);
                    const label = createElement('label', ['block', 'text-sm', 'font-bold', 'mb-2']);
                    label.htmlFor = id;
                    label.textContent = labelText;
                    
                    const input = createElement('input', ['input-field', 'rounded', 'w-full', 'p-2']);
                    input.type = 'number';
                    input.id = id;
                    input.placeholder = placeholder;
                    
                    wrapper.appendChild(label);
                    wrapper.appendChild(input);
                    if (additionalHtml) {
                        const div = createElement('div');
                        div.innerHTML = additionalHtml;
                        wrapper.appendChild(div);
                    }
                    return wrapper;
                };

                // --- æ¸²æŸ“å·¦å´ã€Œè§’è‰²ç›®å‰ç­‰ç´šã€å€å¡Š ---
                const renderLevelInputs = () => {
                    const fragment = document.createDocumentFragment();

                    // è§’è‰²èˆ‡å¹»ç¸
                    const charPetWrapper = createElement('div', ['grid', 'grid-cols-2', 'sm:grid-cols-5', 'gap-4', 'mb-4', 'border-b', 'border-[#e5eff1]', 'pb-6']);
                    const charCat = categories.find(c => c.id === 'character');
                    if(charCat) charPetWrapper.appendChild(createInputGroup(`${charCat.id}-current`, charCat.name, 'ç›®å‰'));
                    categories.filter(c => c.id.startsWith('pet')).forEach(cat => {
                        charPetWrapper.appendChild(createInputGroup(`${cat.id}-current`, cat.name, 'ç›®å‰'));
                    });
                    fragment.appendChild(charPetWrapper);

                    // è£å‚™
                    const equipTitle = createElement('h3', ['text-lg', 'font-semibold', 'text-accent', 'pb-2', 'mb-3']);
                    equipTitle.textContent = 'è£å‚™ç­‰ç´š';
                    fragment.appendChild(equipTitle);
                    const equipWrapper = createElement('div', ['grid', 'grid-cols-2', 'gap-x-6', 'mb-4', 'border-b', 'border-[#e5eff1]', 'pb-6']);
                    const equipCol1 = createElement('div');
                    const equipCol2 = createElement('div');
                    categories.filter(c => c.group === 'è£å‚™ç­‰ç´š').forEach((cat, i) => {
                        (i < 2 ? equipCol1 : equipCol2).appendChild(createInputGroup(`${cat.id}-current`, cat.name, 'ç›®å‰', true));
                    });
                    equipWrapper.append(equipCol1, equipCol2);
                    fragment.appendChild(equipWrapper);

                    // æŠ€èƒ½
                    const skillTitle = createElement('h3', ['text-lg', 'font-semibold', 'text-accent', 'pb-2', 'mb-3']);
                    skillTitle.textContent = 'æŠ€èƒ½ç­‰ç´š';
                    fragment.appendChild(skillTitle);
                    const skillWrapper = createElement('div', ['grid', 'grid-cols-2', 'gap-x-6', 'mb-4', 'border-b', 'border-[#e5eff1]', 'pb-6']);
                    const skillCol1 = createElement('div');
                    const skillCol2 = createElement('div');
                    categories.filter(c => c.id.startsWith('skill_combat')).forEach(cat => skillCol1.appendChild(createInputGroup(`${cat.id}-current`, cat.name, 'ç›®å‰', true)));
                    categories.filter(c => c.id.startsWith('skill_arcane')).forEach(cat => skillCol2.appendChild(createInputGroup(`${cat.id}-current`, cat.name, 'ç›®å‰', true)));
                    skillWrapper.append(skillCol1, skillCol2);
                    fragment.appendChild(skillWrapper);
                    
                    containers.levelInputs.appendChild(fragment);
                };

                // --- æ¸²æŸ“é ‚éƒ¨ã€Œç›®æ¨™ç­‰ç´šã€å€å¡Š ---
                const renderTargetLevels = () => {
                    targetLevelConfig.forEach(t => {
                        let reachableHtml = (t.id === 'character') ? `<div id="target-char-reachable-level" class="text-xs text-gray-500 mt-1">æœ€ä½å¯é”: --</div>` : '';
                        containers.targetLevels.appendChild(createInputGroup(`target-${t.id}`, t.name, 'ç›®æ¨™', false, reachableHtml));
                    });
                };

                // --- æ¸²æŸ“ã€Œéºç‰©ç­‰ç´šåˆ†ä½ˆã€å€å¡Š ---
                const renderRelicDistribution = () => {
                    for (let i = 10; i <= 20; i++) {
                        const group = createInputGroup(`relic-level-${i}`, `ç­‰ç´š ${i}`, 'æ•¸é‡');
                        group.querySelector('input').classList.add('relic-dist-input');
                        containers.relicDistributionInputs.appendChild(group);
                    }
                };
                
                // --- æ¸²æŸ“å³å´ã€Œç´ æè³‡è¨Šã€å€å¡Š ---
                const renderMaterials = () => {
                    Object.entries(materials).forEach(([matId, mat]) => {
                        const wrapper = createElement('div', ['flex', 'items-center']);
                        const label = createElement('label', ['w-full', 'block', 'text-sm', 'font-bold']);
                        label.htmlFor = `owned-${matId}`;
                        label.textContent = `${mat.icon} ${mat.name}`;
                        const input = createElement('input', ['input-field', 'rounded', 'w-full', 'p-2']);
                        input.type = 'number';
                        input.id = `owned-${matId}`;
                        input.placeholder = '0';
                        wrapper.append(label, input);
                        containers.ownedMaterials.appendChild(wrapper);
                    });
                };
                
                // --- æ¸²æŸ“ä¸­é–“ã€Œæ¨è»Šç”¢é‡ã€å€å¡Š ---
                const renderProduction = () => {
                    Object.entries(productionSources).forEach(([srcId, src]) => {
                        const mat = materials[src.materialId];
                        const wrapper = createElement('div');
                        
                        const mainLabel = createElement('label', ['block', 'text-sm', 'font-bold', 'mb-2']);
                        mainLabel.textContent = `${mat.icon} ${mat.name}`;
                        wrapper.appendChild(mainLabel);

                        const grid = createElement('div', ['grid', 'grid-cols-2', 'gap-2']);
                        
                        // ç”Ÿç”¢ç­‰ç´šéƒ¨åˆ†
                        const levelDiv = createElement('div');
                        const levelLabel = createElement('label', ['text-xs', 'text-gray-500']);
                        levelLabel.textContent = 'ç”Ÿç”¢ç­‰ç´š';
                        const levelGrid = createElement('div', ['grid', 'grid-cols-2', 'gap-1']);
                        const currentLevelInput = createInputGroup(`prod-level-current-${srcId}`, '', 'ç›®å‰').querySelector('input');
                        currentLevelInput.classList.add('production-related-input', 'text-sm');
                        const targetLevelInput = createInputGroup(`prod-level-target-${srcId}`, '', 'ç›®æ¨™').querySelector('input');
                        targetLevelInput.classList.add('production-related-input', 'text-sm');
                        levelGrid.append(currentLevelInput.parentElement, targetLevelInput.parentElement);
                        levelDiv.append(levelLabel, levelGrid);
                        
                        // æ™‚ç”¢é‡éƒ¨åˆ†
                        const hourlyDiv = createElement('div');
                        const hourlyLabel = createElement('label', ['text-xs', 'text-gray-500']);
                        hourlyLabel.textContent = 'æ™‚ç”¢é‡ (ç†è«–/æ‰‹å‹•)';
                        const hourlyGrid = createElement('div', ['grid', 'grid-cols-2', 'gap-1']);
                        const theoreticalInput = createInputGroup(`theoretical-hourly-${srcId}`, '', 'ç†è«–').querySelector('input');
                        theoreticalInput.classList.add('text-sm');
                        theoreticalInput.disabled = true;
                        const manualInput = createInputGroup(`manual-hourly-${srcId}`, '', 'æ‰‹å‹•').querySelector('input');
                        manualInput.classList.add('text-sm');
                        hourlyGrid.append(theoreticalInput.parentElement, manualInput.parentElement);
                        hourlyDiv.append(hourlyLabel, hourlyGrid);
                        
                        grid.append(levelDiv, hourlyDiv);
                        wrapper.appendChild(grid);
                        containers.productionInputs.appendChild(wrapper);
                    });

                    Object.entries(globalBonuses).forEach(([bonusId, bonus]) => {
                         const group = createInputGroup(`bonus-${bonusId}`, bonus.name, '0');
                         group.querySelector('input').classList.add('production-related-input');
                         containers.globalBonuses.appendChild(group);
                    });
                };

                // --- åŸ·è¡Œæ‰€æœ‰æ¸²æŸ“å‡½å¼ ---
                renderLevelInputs();
                renderTargetLevels();
                renderRelicDistribution();
                renderMaterials();
                renderProduction();
            }

            /**
             * @description æ›´æ–°ã€Œç¾åœ¨æ™‚é–“ã€çš„é¡¯ç¤ºã€‚
             */
            function updateCurrentTime() {
                if (containers.currentTimeDisplay) {
                    const now = new Date();
                    const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
                    containers.currentTimeDisplay.textContent = now.toLocaleString('sv-SE', options);
                }
            }

            /**
             * @description æ›´æ–°éºç‰©åˆ†ä½ˆå€å¡Šçš„ç¸½æ•¸é¡¯ç¤ºã€‚
             */
            function updateRelicTotal() {
                let total = 0;
                document.querySelectorAll('.relic-dist-input').forEach(el => { total += parseInt(el.value) || 0; });
                const display = document.getElementById('relic-total-display');
                display.textContent = `(${total}/20)`;
                if (total !== 20 && total > 0) { display.classList.add('text-warning'); display.classList.remove('text-gray-400'); } 
                else { display.classList.remove('text-warning'); display.classList.add('text-gray-400'); }
            }

            /**
             * @description ç•¶ç”Ÿç”¢ç­‰ç´šæˆ–å…¨åŸŸåŠ æˆè®Šå‹•æ™‚ï¼Œé‡æ–°è¨ˆç®—ç†è«–æ™‚ç”¢é‡ã€‚
             */
            function updateTheoreticalProduction() {
                // [è¨ˆç®—] æ­¤è™•ç‚ºå…¨åŸŸåŠ æˆçš„è¨ˆç®—å…¬å¼
                const totalBonus = 1 +
                    (parseFloat(document.getElementById('bonus-map').value) || 0) / 100 +
                    (parseFloat(document.getElementById('bonus-relic').value) || 0) / 100 +
                    (parseFloat(document.getElementById('bonus-pass').value) || 0) / 100;
                for (const srcId in productionSources) {
                    const level = parseInt(document.getElementById(`prod-level-current-${srcId}`).value) || 0;
                    const baseProd = level > 0 ? productionSources[srcId].baseProd(level) : 0;
                    document.getElementById(`theoretical-hourly-${srcId}`).value = Math.floor(baseProd * totalBonus);
                }
            }

            /**
             * @description ä¸»è¨ˆç®—å‡½å¼ï¼Œæœƒè¢«æ‰€æœ‰è¼¸å…¥æ¡†çš„ 'input' äº‹ä»¶è§¸ç™¼ã€‚
             */
            function calculate() {
                let required = {}, prodUpgradeCost = {}, hasError = false, hasInput = false;
                const missingDataErrors = []; 

                // --- è®€å–æ‰€æœ‰ç›®æ¨™ç­‰ç´š ---
                const targets = {};
                targetLevelConfig.forEach(t => { targets[t.id] = parseInt(document.getElementById(`target-${t.id}`).value) || 0; });
                
                // --- è¨ˆç®—ä¸¦æ›´æ–°ã€Œæœ€ä½å¯é”ç­‰ç´šã€ ---
                const reachableCharLevelDisplay = document.getElementById('target-char-reachable-level');
                const currentCharacterLevel = parseInt(document.getElementById('character-current').value) || 0;
                const ownedExp = parseInt(document.getElementById('owned-exp').value) || 0;
                const bedExpHourly = parseFloat(document.getElementById('bed-exp-hourly').value) || 0;
                const targetTimeStr = document.getElementById('target-time').value;
                let reachableCharLevel = currentCharacterLevel;
                
                // TODO: [è¨ˆç®—] æœ€ä½å¯é”è§’è‰²ç­‰ç´šçš„è¨ˆç®—é‚è¼¯
                if (targetTimeStr && cumulativeCostData['character']) {
                    const hours = Math.max(0, (new Date(targetTimeStr).getTime() - new Date().getTime()) / 36e5);
                    const currentInvestedExp = getCumulativeCost(cumulativeCostData['character'], currentCharacterLevel - 1).cost_exp;
                    const totalExpPool = currentInvestedExp + ownedExp + (bedExpHourly * hours);
                    const foundIndex = cumulativeCostData['character'].findLastIndex(d => d.cost_exp <= totalExpPool);
                    reachableCharLevel = (foundIndex !== -1) ? cumulativeCostData['character'][foundIndex].level : currentCharacterLevel;
                }
                
                // æ›´æ–°ä»‹é¢é¡¯ç¤º
                reachableCharLevelDisplay.textContent = `æœ€ä½å¯é”: ${reachableCharLevel > 0 ? reachableCharLevel : '--'}`;

                // --- éºç‰©æˆæœ¬è¨ˆç®— ---
                // TODO: [è¨ˆç®—] éºç‰©å‡ç´šæ‰€éœ€æˆæœ¬çš„æ ¸å¿ƒè¨ˆç®—é‚è¼¯
                const targetRelicResonance = targets.relic_resonance;
                let relicCount = 0;
                for (let i = 10; i <= 20; i++) {
                    const count = parseInt(document.getElementById(`relic-level-${i}`).value) || 0;
                    if (count > 0) hasInput = true;
                    relicCount += count;
                    for (let j = 0; j < count; j++) {
                        const current = i;
                        const finalTarget = Math.max(current, targetRelicResonance);
                        if (finalTarget > current) {
                            const costTable = cumulativeCostData.relic;
                            const sourceDataTable = GAME_DATA.relicUpgradeCosts;
                            let missingLevelFound = false;
                            for (let lvl = current; lvl < finalTarget; lvl++) {
                                if (!sourceDataTable.find(d => d.level === lvl)) {
                                    missingDataErrors.push(`éºç‰©ç¼ºå°‘ ${lvl} ç´šçš„å‡ç´šæ•¸æ“š`);
                                    missingLevelFound = true;
                                    break;
                                }
                            }
                            if (!missingLevelFound && costTable) {
                                const startCost = getCumulativeCost(costTable, current - 1);
                                const endCost = getCumulativeCost(costTable, finalTarget - 1);
                                Object.keys(endCost).forEach(key => {
                                    if (key.startsWith('cost_')) {
                                        const matId = getMaterialIdFromCostKey(key);
                                        const startValue = startCost[key] || 0;
                                        required[matId] = (required[matId] || 0) + (endCost[key] - startValue);
                                    }
                                });
                            }
                        }
                    }
                }
                if (relicCount > 0 && relicCount !== 20) { hasError = true; }

                // --- å…¶ä»–é …ç›®æˆæœ¬è¨ˆç®— ---
                // TODO: [è¨ˆç®—] è§’è‰²ã€è£å‚™ã€æŠ€èƒ½ã€å¹»ç¸å‡ç´šæ‰€éœ€æˆæœ¬çš„æ ¸å¿ƒè¨ˆç®—é‚è¼¯
                categories.forEach(cat => {
                    const current = parseInt(document.getElementById(`${cat.id}-current`).value) || 0;
                    if (current > 0) hasInput = true;
                    let targetResonance = 0;
                    if (cat.id === 'character') { targetResonance = targets.character; } 
                    else if (cat.id.startsWith('equipment_')) { targetResonance = targets.equipment_resonance; } 
                    else if (cat.id.startsWith('skill_')) { targetResonance = targets.skill_resonance; } 
                    else if (cat.id.startsWith('pet')) { targetResonance = targets.pet_resonance; } 
                    
                    const finalTarget = Math.max(current, targetResonance);
                    if (finalTarget > 0 && !hasInput) hasInput = true;
                    if (finalTarget > current) {
                        let costTable, sourceDataTable, itemName;
                        if (cat.id.startsWith('equipment_')) {
                            costTable = cumulativeCostData.equipment;
                            sourceDataTable = GAME_DATA.equipmentUpgradeCosts;
                            itemName = 'è£å‚™';
                        } else if (cat.id.startsWith('skill_')) {
                            costTable = cumulativeCostData.skill;
                            sourceDataTable = GAME_DATA.skillUpgradeCosts;
                            itemName = 'æŠ€èƒ½';
                        } else if (cat.id.startsWith('pet')) {
                            costTable = cumulativeCostData.pet;
                            sourceDataTable = GAME_DATA.petUpgradeCosts;
                            itemName = 'å¹»ç¸';
                        } else { // è§’è‰²
                            costTable = cumulativeCostData[cat.id];
                            sourceDataTable = GAME_DATA.characterUpgradeCosts;
                            itemName = 'è§’è‰²';
                        }
                        let missingLevelFound = false;
                        if (sourceDataTable) {
                            for (let lvl = current; lvl < finalTarget; lvl++) {
                                if (!sourceDataTable.find(d => d.level === lvl)) {
                                    missingDataErrors.push(`${itemName}ç¼ºå°‘ ${lvl} ç´šçš„å‡ç´šæ•¸æ“š`);
                                    missingLevelFound = true;
                                    break;
                                }
                            }
                        }
                        if (!missingLevelFound && costTable) {
                            const startCost = getCumulativeCost(costTable, current - 1);
                            const endCost = getCumulativeCost(costTable, finalTarget - 1);
                            Object.keys(endCost).forEach(key => {
                                const startValue = startCost[key] || 0;
                                if (key.startsWith('cost_')) {
                                    const matId = getMaterialIdFromCostKey(key);
                                    required[matId] = (required[matId] || 0) + (endCost[key] - startValue);
                                }
                            });
                        }
                    }
                });

                // --- ç”Ÿç”¢å»ºç¯‰å‡ç´šæˆæœ¬è¨ˆç®— ---
                // TODO: [è¨ˆç®—] æ¨è»Šç”Ÿç”¢å»ºç¯‰å‡ç´šæ‰€éœ€æˆæœ¬çš„æ ¸å¿ƒè¨ˆç®—é‚è¼¯
                for (const srcId in productionSources) {
                    const current = parseInt(document.getElementById(`prod-level-current-${srcId}`).value) || 0;
                    const target = parseInt(document.getElementById(`prod-level-target-${srcId}`).value) || 0;
                    if (target > current) {
                        const sourceDataTable = GAME_DATA.productionUpgradeCosts;
                        let missingLevelFound = false;
                        for (let lvl = current; lvl < target; lvl++) {
                            if (!sourceDataTable.find(d => d.level === lvl)) {
                                missingDataErrors.push(`æ¨è»Š(${materials[productionSources[srcId].materialId].name})ç¼ºå°‘ ${lvl} ç´šçš„å‡ç´šæ•¸æ“š`);
                                missingLevelFound = true;
                                break;
                            }
                        }
                        if (!missingLevelFound) {
                            const costTable = cumulativeCostData.production;
                            const startCost = getCumulativeCost(costTable, current - 1);
                            const endCost = getCumulativeCost(costTable, target - 1);
                            Object.keys(endCost).forEach(key => {
                                if (key.startsWith('cost_')) {
                                    const matId = getMaterialIdFromCostKey(key);
                                    const startValue = startCost[key] || 0;
                                    prodUpgradeCost[matId] = (prodUpgradeCost[matId] || 0) + (endCost[key] - startValue);
                                }
                            });
                        }
                    }
                }
                const uniqueMissingDataErrors = [...new Set(missingDataErrors)];
                if (hasError || uniqueMissingDataErrors.length > 0) {
                    let errorHtml = '';
                    if (hasError) { errorHtml += '<p class="text-warning text-center py-4">è¼¸å…¥æœ‰èª¤ (ä¾‹å¦‚éºç‰©ç¸½æ•¸ä¸ç‚º20)ï¼Œè«‹æª¢æŸ¥ã€‚</p>'; }
                    if (uniqueMissingDataErrors.length > 0) {
                        errorHtml += `<div class="bg-red-900/50 border-l-4 border-red-400 text-red-300 p-3 rounded-lg mb-4 text-sm"><h4 class="font-bold">æ•¸æ“šç¼ºå¤±</h4><p>CSVæª”æ¡ˆä¸­ç¼ºå°‘ä»¥ä¸‹ç­‰ç´šçš„æ•¸æ“šï¼Œè¨ˆç®—ç„¡æ³•å®Œæˆï¼š<br>${uniqueMissingDataErrors.join('<br>')}</div>`;
                    }
                    containers.results.innerHTML = errorHtml;
                    return;
                }
                if (!hasInput) { renderResults({}, {}, {}, {}); return; }
                
                // TODO: [è¨ˆç®—] æ›æ©Ÿæ”¶ç›Šè¨ˆç®—é‚è¼¯
                let gainsFromTime = {};
                if (targetTimeStr) {
                    const hours = Math.max(0, (new Date(targetTimeStr).getTime() - new Date().getTime()) / 36e5);
                    for (const srcId in productionSources) {
                        const manual = parseFloat(document.getElementById(`manual-hourly-${srcId}`).value) || 0;
                        const theoretical = parseFloat(document.getElementById(`theoretical-hourly-${srcId}`).value) || 0;
                        const hourlyGain = manual > 0 ? manual : theoretical;
                        gainsFromTime[productionSources[srcId].materialId] = (gainsFromTime[productionSources[srcId].materialId] || 0) + Math.floor(hourlyGain * hours);
                    }
                    if (bedExpHourly > 0) { gainsFromTime['exp'] = (gainsFromTime['exp'] || 0) + Math.floor(bedExpHourly * hours); }
                }

                // TODO: [è¨ˆç®—] æœ€çµ‚è³‡æºç¼ºå£è¨ˆç®—é‚è¼¯
                let deficit = {};
                for (const matId in materials) {
                    const totalRequired = (required[matId] || 0) + (prodUpgradeCost[matId] || 0);
                    const owned = parseInt(document.getElementById(`owned-${matId}`).value) || 0;
                    const gained = gainsFromTime[matId] || 0;
                    deficit[matId] = Math.max(0, totalRequired - owned - gained);
                }
                
                updateLevelUpTimeAndNotification(currentCharacterLevel, ownedExp, bedExpHourly);
                renderResults(required, prodUpgradeCost, gainsFromTime, deficit);
            }

            /**
             * @description è¨ˆç®—ä¸¦æ›´æ–°ä¸‹æ¬¡å‡ç´šæ‰€éœ€æ™‚é–“åŠè¨­å®šé€šçŸ¥ã€‚
             */
            function updateLevelUpTimeAndNotification(currentLevel, ownedExp, bedExpHourly) {
                const levelUpTimeDisplay = document.getElementById('bed-levelup-time');
                if (notificationTimerId) { clearTimeout(notificationTimerId); notificationTimerId = null; }
                if (bedExpHourly <= 0 || currentLevel >= MAX_LEVEL) { levelUpTimeDisplay.textContent = 'é è¨ˆå‡ç´šæ™‚é–“: --'; return; }
                
                // TODO: [è¨ˆç®—] è§’è‰²ä¸‹æ¬¡å‡ç´šæ™‚é–“çš„è¨ˆç®—é‚è¼¯
                // 1) é–€æª»ï¼ˆæ²¿ç”¨ä½ çš„æ¨¡å‹ï¼šcurrentLevel æ˜¯ã€Œä¸‹ä¸€ç´šé–€æª»ã€ï¼‰
                const nextCum    = getCumulativeCost(cumulativeCostData['character'], currentLevel).cost_exp;
                const currentCum = getCumulativeCost(cumulativeCostData['character'], currentLevel - 1).cost_exp;

                // 2) å°šéœ€ç¶“é©—ï¼ˆownedExp ç‚ºç•¶å‰ç­‰ç´šå…§å·²ç´¯ç©ï¼‰
                const expNeeded = Math.max(0, Number(nextCum) - Number(currentCum) - (Number(ownedExp) || 0));
                let levelupTs = NaN; // ğŸ”´ ç”¨æ¯«ç§’æ•¸ï¼Œå¤–å±¤å¯è¢«å¾ŒçºŒæ¨æ’­é‚è¼¯è®€åˆ°

                console.log({ nextCum, currentCum, ownedExp, expNeeded });

                if (expNeeded <= 0) {
                levelUpTimeDisplay.textContent = 'é è¨ˆå‡ç´šæ™‚é–“: å¯ç«‹å³å‡ç´š';
                } else {
                // 3) ä¼°ç®—æ‰€éœ€æ™‚é–“
                const ratePerHour = Number(bedExpHourly);
                if (!Number.isFinite(ratePerHour) || ratePerHour <= 0) {
                    levelUpTimeDisplay.textContent = 'é è¨ˆå‡ç´šæ™‚é–“: è«‹å…ˆè¼¸å…¥åºŠçš„æ¯å°æ™‚ç¶“é©—ç”¢é‡';
                } else {
                    const ratePerSec = ratePerHour / 3600;
                    const secondsNeeded = Math.ceil(expNeeded / ratePerSec);
                    const minutesNeeded = Math.ceil(secondsNeeded / 60); // å‘ä¸Šå–æ•´åˆ°åˆ†é˜
                    levelupTs = Date.now() + minutesNeeded * 60 * 1000;

                    const timeStr = new Date(levelupTs).toLocaleString('zh-TW', {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit'
                    });
                    levelUpTimeDisplay.textContent = `é è¨ˆå‡ç´šæ™‚é–“: ${timeStr}ï¼ˆç´„ ${minutesNeeded.toLocaleString()} åˆ†é˜ï¼‰`;
                }
                }

                // 4) æ¨æ’­ï¼ˆé é¢é—œé–‰ä¸æœƒè§¸ç™¼ï¼›æ¯æ¬¡é‡ç®—éƒ½é‡æ’ï¼‰
                if (notificationTimerId) {
                clearTimeout(notificationTimerId);
                notificationTimerId = null;
                }

                if ('Notification' in window && Notification.permission === 'granted') {
                if (bedExpHourly > 0 && expNeeded > 0 && Number.isFinite(levelupTs) && levelupTs > Date.now()) {
                    // å°é½Šåˆ°ä¸‹ä¸€å€‹æ•´åˆ†é˜å†æå‰ 3 åˆ†é˜ï¼Œé¿å…ææ—©
                    const alignedLvTs = Math.ceil(levelupTs / 60000) * 60000;
                    const notifyAt = alignedLvTs - 3 * 60 * 1000;
                    const delay = notifyAt - Date.now();

                    if (delay > 0) {
                    const MAX_DELAY = 0x7fffffff; // ç´„ 24.8 å¤©
                    const schedule = (ms) => {
                        if (ms > MAX_DELAY) {
                        notificationTimerId = setTimeout(() => schedule(ms - MAX_DELAY), MAX_DELAY);
                        } else {
                        notificationTimerId = setTimeout(() => {
                            new Notification('æ–åŠå‚³èªªæé†’', {
                            body: `æ‚¨çš„è§’è‰²ç´„ 3 åˆ†é˜å¾Œå¯å‡ç´šè‡³ ${currentLevel + 1} ç´šï¼`,
                            icon: 'https://placehold.co/192x192/31c9be/ffffff?text=LV'
                            });
                            notificationTimerId = null;
                        }, ms);
                        }
                    };
                    schedule(delay);
                    // console.debug({ alignedLvTs: new Date(alignedLvTs), notifyAt: new Date(notifyAt), delay });
                    }
                }
                }



            }

            /**
             * @description å°‡è¨ˆç®—çµæœæ¸²æŸ“åˆ°å³å´çš„ã€Œè¨ˆç®—ç¸½è¦½ã€å€å¡Šã€‚
             */
            function renderResults(req, prodCost, gains, deficit) {
                let html = '';
                if (missingFiles.length > 0) { html += `<div class="bg-yellow-900/50 border-l-4 border-yellow-400 text-yellow-300 p-3 rounded-lg mb-4 text-sm"><h4 class="font-bold">æ³¨æ„</h4><p>ç„¡æ³•è¼‰å…¥ä»¥ä¸‹æ•¸æ“šæª”æ¡ˆï¼Œç›®å‰æ­£ä½¿ç”¨æ¨¡æ“¬æ•¸æ“šï¼š<br>${missingFiles.join(', ')}</p></div>`; }
                const formatNum = (n) => n.toLocaleString();
                let costHtml = '';
                for (const matId in req) { if (req[matId] > 0) { costHtml += `<div class="flex justify-between items-center text-sm"><span>${materials[matId].icon} ${materials[matId].name}</span><strong>${formatNum(req[matId])}</strong></div>`; } }
                if (costHtml) { html += `<div class="cost-item p-3 rounded-lg space-y-1"><h4 class="font-bold text-gold">è§’è‰²é¤Šæˆæ‰€éœ€</h4>${costHtml}</div>`; }
                let prodCostHtml = '';
                for (const matId in prodCost) { if (prodCost[matId] > 0) { prodCostHtml += `<div class="flex justify-between items-center text-sm"><span>${materials[matId].icon} ${materials[matId].name}</span><strong>${formatNum(prodCost[matId])}</strong></div>`; } }
                if (prodCostHtml) { html += `<div class="cost-item p-3 rounded-lg space-y-1"><h4 class="font-bold text-gold">ç”Ÿç”¢ç­‰ç´šå‡ç´šæ‰€éœ€</h4>${prodCostHtml}</div>`; }
                let gainsHtml = '';
                for (const matId in gains) { if (gains[matId] > 0) { gainsHtml += `<div class="flex justify-between items-center text-sm"><span>${materials[matId].icon} ${materials[matId].name}</span><strong class="text-accent">+${formatNum(gains[matId])}</strong></div>`; } }
                if (gainsHtml) { html += `<div class="info-item p-3 rounded-lg space-y-1"><h4 class="font-bold text-accent">é è¨ˆæ›æ©Ÿç²å¾—</h4>${gainsHtml}</div>`; }
                let deficitHtml = '';
                for (const matId in deficit) {
                    if (deficit[matId] > 0) {
                        deficitHtml += `<div class="result-item p-4 rounded-lg flex justify-between items-center"><div class="flex items-center"><span class="text-2xl mr-3">${materials[matId].icon}</span><span class="font-bold text-lg">${materials[matId].name}</span></div><strong class="text-xl font-semibold text-warning">-${formatNum(deficit[matId])}</strong></div>`;
                    }
                }
                if (deficitHtml) { html += `<h3 class="text-xl font-bold text-warning border-t border-[#e5eff1] pt-4 mt-4">æœ€çµ‚è³‡æºç¼ºå£</h3>` + deficitHtml; } 
                else if (costHtml || prodCostHtml) { html += '<p class="text-green-400 text-center py-6 font-bold text-lg">æ­å–œï¼æ ¹æ“šè¨ˆç®—ï¼Œä½ çš„è³‡æºå·²å®Œå…¨è¶³å¤ ï¼</p>'; }
                containers.results.innerHTML = html || '<p class="text-gray-500 text-center py-8">è«‹è¼¸å…¥è³‡æ–™ä»¥è‡ªå‹•è¨ˆç®—ã€‚</p>';
            }

            /**
             * @description ç¶å®šæ‰€æœ‰è¼¸å…¥æ¡†çš„äº‹ä»¶ç›£è½å™¨ä»¥è§¸ç™¼è‡ªå‹•è¨ˆç®—ã€‚
             */
            function setupEventListeners() {
                document.body.addEventListener('input', (event) => {
                    const target = event.target;
                    if (target.matches('input[type=number], input[type=datetime-local]')) {
                        if (target.classList.contains('production-related-input')) { updateTheoreticalProduction(); }
                        if (target.classList.contains('relic-dist-input')) { updateRelicTotal(); }
                        calculate();
                    }
                });

                const notificationBtn = document.getElementById('enable-notifications-btn');
                if ('Notification' in window) {
                    notificationBtn.addEventListener('click', () => {
                        Notification.requestPermission().then(permission => {
                            if (permission === 'granted') {
                                notificationBtn.textContent = 'é€šçŸ¥å·²å•Ÿç”¨';
                                notificationBtn.disabled = true;
                                new Notification('é€šçŸ¥å·²å•Ÿç”¨', { body: 'å°‡åœ¨è§’è‰²å‡ç´šå‰ 3 åˆ†é˜æé†’æ‚¨ï¼' });
                            } else {
                                notificationBtn.textContent = 'é€šçŸ¥è¢«æ‹’çµ•';
                                notificationBtn.disabled = true;
                            }
                        });
                    });
                } else {
                    notificationBtn.textContent = 'ç€è¦½å™¨ä¸æ”¯æ´é€šçŸ¥';
                    notificationBtn.disabled = true;
                }
            }

            render();
            setupEventListeners();
            updateTheoreticalProduction();
            updateRelicTotal();
            setInterval(updateCurrentTime, 1000);
            updateCurrentTime();
            calculate(); // åˆå§‹è¨ˆç®—ä¸€æ¬¡
        }
    </script>
</body>
</html>
